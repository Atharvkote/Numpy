INDEX
Sr no	Topics	
1	Introduction 	
2	Basic Python(All Basic)	
3	Python is the collection type(Tup,list,set,dict)	
4	File Handling	
5	Exception handlng	
6	Function	
7	Working with the JSON file	
8	List Comprehension	
9	Operation on the csv file	
10	Lambda function	
11	Python For Datascience (Pandas)	
12	Pandas data Frame operation	
13	Shuffle	
14	Join	
15	Pandas Series	
16	Graph	
17	Use of Numpy	
18	Operation on array and matrix	
19		
20		
		
	
		
Data Science
Introduction
What is Python?
Python is a high-level, general-purpose, and very popular programming language. Python programming language (latest Python 3) is being used in web development, Machine Learning applications, along with all cutting-edge technology in Software Industry. Python language is being used by almost all tech-giant companies like – Google, Amazon, Facebook, Instagram, Dropbox, Uber… etc.
The biggest strength of Python is huge collection of standard library which can be used for the following:
	Machine Learning
	GUI Applications (like Kivy, Tkinter, PyQt etc. )
	Web frameworks like Django (used by YouTube, Instagram, Dropbox)
	Image processing (like OpenCV, Pillow)
	Web scraping (like Scrapy, BeautifulSoup, Selenium)
	Test frameworks
	Multimedia
	Scientific computing
	Text processing and many more.
	.
Why Learn Python?
Python is currently the most widely used multi-purpose, high-level programming language, which allows programming in Object-Oriented and Procedural paradigms. Python programs generally are smaller than other programming languages like Java. Programmers have to type relatively less and the indentation requirement of the language, makes them readable all the time.
Basics, Input/Output, Data Types, Variables, Operators, Control Flow, Functions, Object Oriented Concepts, Exception Handling, Python Collections, Django Framework, Data Analysis, Numpy, Pandas, Machine Learning with Python, Python GUI, Modules in Python, Working with Database, Misc, Applications and Projects, Multiple Choice Questions

Python is a high-level, interpreted, and general-purpose dynamic programming language that focuses on code readability. It generally has small programs when compared to Java and C. It was founded in 1991 by developer Guido Van Rossum. Python ranks among the most popular and fastest-growing languages in the world. Python is a powerful, flexible, and easy-to-use language. In addition, the python community is very active. It is used in many organizations as it supports multiple programming paradigms. It also performs automatic memory management.

Advantages:
	Presence of third-party modules
	Extensive support libraries(NumPy for numerical calculations, Pandas for data analytics, etc.)
	Open source and large active community base
	Versatile, Easy to read, learn and write
	User-friendly data structures
	High-level language
	Dynamically typed language(No need to mention data type based on the value assigned, it takes data type)
	Object-Oriented and Procedural  Programming language
	Portable and Interactive
	Ideal for prototypes – provide more functionality with less coding
	Highly Efficient(Python’s clean object-oriented design provides enhanced process control, and the language is equipped with excellent text processing and integration capabilities, as well as its own unit testing framework, which makes it more efficient.)
	Internet of Things(IoT) Opportunities
	Interpreted Language
	Portable across Operating systems

Disadvantages:
	Performance: Python is an interpreted language, which means that it can be slower than compiled languages like C or Java. This can be an issue for performance-intensive tasks.
	Global Interpreter Lock: The Global Interpreter Lock (GIL) is a mechanism in Python that prevents multiple threads from executing Python code at once. This can limit the parallelism and concurrency of some applications.
	Memory consumption: Python can consume a lot of memory, especially when working with large datasets or running complex algorithms.
	Dynamically typed: Python is a dynamically typed language, which means that the types of variables can change at runtime. This can make it more difficult to catch errors and can lead to bugs.
	Packaging and versioning: Python has a large number of packages and libraries, which can sometimes lead to versioning issues and package conflicts.
	Lack of strictness: Python’s flexibility can sometimes be a double-edged sword. While it can be great for rapid development and prototyping, it can also lead to code that is difficult to read and maintain.
	Steep learning curve: While Python is generally considered to be a relatively easy language to learn, it can still have a steep learning curve for beginners, especially if they have no prior experience with programming.

Applications:
	GUI-based desktop applications
	Graphic design, image processing applications, Games, and Scientific/ computational Applications
	Web frameworks and applications
	Enterprise and Business applications
	Operating Systems
	Education
	Database Access
	Language Development
	Prototyping
	Software Development
	Data Science and Machine Learning
 
Scripting organizations using Python :
	Google(Components of Google spider and Search Engine)
	Yahoo(Maps)
	YouTube
	Mozilla
	Dropbox
	Microsoft
	Cisco
	Spotify
	Quora
	Facebook

Python 3 basics
Python 3 is a popular high-level programming language used for a wide variety of applications. Here are some basics of Python 3 that you should know:
	Variables: In Python 3, variables are created by assigning a value to a name. For example, x = 5 creates a variable called x and assigns the value 5 to it.
	Data types: Python 3 supports several built-in data types, including integers, floats, strings, booleans, lists, tuples, and dictionaries.
	Operators: Python 3 supports a variety of operators, including arithmetic operators (+, -, *, /), comparison operators (>, <, ==, !=), and logical operators (and, or, not).
	Control flow statements: Python 3 supports several control flow statements, including if-else statements, for loops, and while loops. These statements allow you to control the flow of execution in your code.
	Functions: In Python 3, functions are created using the def keyword. For example, def my_function(x): creates a function called my_function that takes one argument called x.
	Input and output: In Python 3, you can use the input() function to get user input, and the print() function to output text to the console.
	Modules: Python 3 supports modules, which are collections of functions and variables that can be imported and used in other Python code. You can import modules using the import keyword.

Advantages of Python 3:
	Python 3 has a simple syntax that is easy to learn and read, making it a good choice for beginners.
	Python 3 is a high-level language that has a large standard library and many third-party libraries available, making it a versatile language that can be used for a wide variety of applications.
	Python 3 supports multiple programming paradigms, including object-oriented, functional, and procedural programming.
	Python 3 is an interpreted language, meaning that it does not need to be compiled before running, making it easy to write and test code quickly.
	Python 3 has good support for data analysis and scientific computing, with libraries such as NumPy and Pandas.

Disadvantages of Python 3:
	Python 3 can be slower than compiled languages such as C++ or Java, which may be a concern for applications that require high performance.
	Python 3 has a global interpreter lock (GIL), which can limit its ability to take advantage of multiple CPU cores.
	Python 3 may not be the best choice for low-level systems programming, as it does not offer the same level of control over hardware as other languages.
	Python 3 is not as popular in some fields as other languages, such as R for data analysis or C++ for game development, so it may not always be the best choice for specific applications.
	Python was developed by Guido van Rossum in the early 1990s and its latest version is 3.11.0, we can simply call it Python3. Python 3.0 was released in 2008. and is interpreted language i.e it’s not compiled and the interpreter will check the code line by line. This article can be used to learn the very basics of Python programming language. So before moving on further.. let’s do the most popular ‘HelloWorld’ tradition and hence compare Python’s Syntax with C, C++, and Java ( I have taken these 3 because they are the most famous and mostly used languages).



BASIC Python
Basic program:-
#print Hello World

print('Hello World')
O/p:- Hello word

"”” .py extension. Such a file can contain one or more Python statements that represent a Python program or Script."""
Note: Please note that Python for its scope doesn’t depend on the braces ( { } ), instead it uses indentation for its scope
In the python2 the ‘print’ is not the function  but a keyword and therefore can be used without parentheses In python 3  the “print” is the function and must be involked with paraentheses

Variables
Variables are containers for storing data values.
Creating Variables:-Python has no command for declaring a variable. A variable is created the moment you first assign a value to it.
#Types of Numbers-There are three types used to represent numbers in Python; these are integers (or integral) types, floating point numbers and complex numbers.

x = 1
print(x)				# o/p:-1
print(type(x)) 			# o/p:- integer
x =100000000000000000000000000000000000000000000000000000000001
print(x)				#o/p:100000000000000000000000000000000000000000000000000000000001
print(type(x))		# o/p:- integer
'''
This makes it very easy to work with integer numbers in Python. Unlike some programming languages such as C# and Java have different integer types depending on the size of the number, small numbers having to be converted into larger types in some situations.
'''
Example
x= 5
y= "John"
print(x)		#o/p:-5
print(y)		#o/p:-John

#Variables do not need to be declared with any particular type, and can even change type after they have been set.
example
x= 4       #x is of type int
x = "Sally" # x is now of type str
print(x)		#o/p:-Sally


Casting
If you want to specify the data type of a variable, this can be done with casting.
Example
x = str(3)    # x will be '3'
y = int(3)    # y will be 3
z = float(3)  # z will be 3.0

Get the Type
You can get the data type of a variable with the type() function.
Example
x = 5
y = "John"
print(type(x))		#o/p:-integer
print(type(y))		#o/p:-string

Single or Double Quotes?
String variables can be declared either by using single or double quotes:
Example
x = "John"		# is the same as
x = 'John'

Case-Sensitive
Variable names are case-sensitive.
Example
This will create two variables:
a = 4
A = "Sally"		#A will not overwrite a

Variable Names
A variable can have a short name (like x and y) or a more descriptive name (age, carname, total_volume).
 Rules for Python variables:
	A variable name must start with a letter or the underscore character
	A variable name cannot start with a number
	A variable name can only contain alpha-numeric characters and underscores (A-z, 0-9, and _ )
	Variable names are case-sensitive (age, Age and AGE are three different variables)
	A variable name cannot be any of the Python keywords.

Example 
Legal variable names:
myvar = "John"
my_var = "John"
_my_var = "John"
myVar = "John"
MYVAR = "John"
myvar2 = "John"



Example
Illegal variable names:
2myvar = "John"
my-var = "John"
my var = "John"
Remember that variable names are case-sensitive

Multi Words Variable Names
Variable names with more than one word can be difficult to read.
There are several techniques you can use to make them more readable:

Camel Case
Each word, except the first, starts with a capital letter:
myVariableName = "John"

Pascal Case
Each word starts with a capital letter:
MyVariableName = "John"

Snake Case
Each word is separated by an underscore character:
my_variable_name = "John"

Many Values to Multiple Variables
Python allows you to assign values to multiple variables in one line:
Example 
x, y, z = "Orange", "Banana", "Cherry"
print(x)						#o/p:- Orange
print(y)						#o/p:-Banana
print(z)						#o/p:- Cherry

Note: Make sure the number of variables matches the number of values, or else you will get an error.

One Value to Multiple Variables
And you can assign the same value to multiple variables in one line:
Example
x = y = z = "Orange"
print(x)	#o/p:-Orange
print(y)	#o/p:-Orange
print(z)		#o/p:-Orange

Unpack a Collection
If you have a collection of values in a list, tuple etc. Python allows you to extract the values into variables. This is called unpacking.
Example
Unpack a list:
fruits = ["apple", "banana", "cherry"]
x, y, z = fruits
print(x)	#o/p:-apple
print(y)	#o/p:-banana
print(z)		#o/p:-cherry
 
Output Variables
The Python print() function is often used to output variables.
Example 
x = "Python is awesome"
print(x)	#o/p:- Python is awesome	

In the print() function, you output multiple variables, separated by a comma:
Example
x = "Python"
y = "is"
z = "awesome"
print(x, y, z)		#o/p:-Python,is, awesome

You can also use the + operator to output multiple variables:
Example
x = "Python "
y = "is "
z = "awesome"
print(x + y + z)	#o/p:- Pythonisawesome
Notice the space character after "Python " and "is ", without them the result would be "Pythonisawesome".

##################################################
For numbers, the + character works as a mathematical operator:
Example
x = 5
y = 10
print(x + y)		#o/p:-15

###################################################
In the print() function, when you try to combine a string and a number with the + operator, Python will give you an error:
Example
x = 5
y = "John"
print(x + y)		#o/p:-error

The best way to output multiple variables in the print() function is to separate them with commas, which even support different data types:
Example
x = 5
y = "John"
print(x, y)	#o/p:-5 John


Global Variables
Variables that are created outside of a function (as in all of the examples above) are known as global variables. Global variables can be used by everyone, both inside of functions and outside.
Example
Create a variable outside of a function, and use it inside the function
x = "awesome"
def myfunc():
  print("Python is " + x)		
myfunc()				#o/p:- Python is awesome

If you create a variable with the same name inside a function, this variable will be local, and can only be used inside the function. The global variable with the same name will remain as it was, global and with the original value.
Example
Create a variable inside a function, with the same name as the global variable
x = "awesome" 	#golable declare
def myfunc():		#function create
 	 x = "fantastic"
  	print("Python is " + x)
myfunc()		
print("Python is " + x) 

#Converting to Ints
It is possible to convert another type into an integer using the int() function. For example, if we want to convert a string into an int (assuming the string contains a integer number) then we can do this using the int() function.

For example 
total = int('100')

This can be useful when used with the input() function. The input() function always returns a string. If we want to ask the user to input   an integer number, then we will need  to convert the string returned from the input() function into an int. We can do this by wrapping the call to the input() function in a call to the int() function.
Example
age = input('Please enter your age:')
print(type(age))				#o/p:-string
print(age)					#o/p:- user need

########################################
example
age1 = input('Please enter your age:')
print(type(age1))				#o.p:- string
print(age1)					#o.p:- user need
 
########################################
example
age2 = input('Please enter your age:')
print(type(age2))				#o.p:- string
print(age2)					#o.p:- as per user need
age=age1+age2				#o.p:- the two string are concatenated
print(age)					#o.p:- 2 concatenated string

########################################
example
age = int(input('Please enter your age:'))
print(type(age))				#o.p:- int
print(age)					#o.p:-- as per user need

########################################
example
age1 = int(input('Please enter your age:'))
print(type(age1))				#o.p:- int
print(age1)					#o.p:- as per user need

########################################
example
age2 = int(input('Please enter your age:'))
print(type(age2))				#o.p:-int
print(age2)					#o.p:- as per user need
age=age1+age2				#o.p:- 2 integer value are added
print(age)					# o.p:- total of the age1and age2

########################################
Floating Point Numbers
Real numbers, or floating point numbers, are represented in Python using the IEEE 754 double-precision binary floating-point number format

Example
exchange_rate = 1.83
print(exchange_rate)					#o.p:- 1.83
print(type(exchange_rate))				#o.p:- float

Converting to Floats
As with integers it is possible to convert other types such as an int or a string into a float.
Example
int_value = 100
string_value = '1.5'
float_value = float(int_value)		# here the integer value are converted into the float
print ('int value as a float:', float_value)	#o.p:- 100.00
print(type(float_value))			#o.p  :- float
float_value = float(string_value)		# here the string is converted into the float
print ('string value as a float:', float_value)	#o.p:-1.5
print(type(float_value))			#o.p:- float




Complex Numbers
c1 = 1
c2 = 2j
print('c1:', c1, ', c2:', c2)		#o.p:- c1:-1;c2:-2j
print(type(c1))				#o.p:-real
print(type(c2))				#o.p:-imagenery
print(c1.real)				#print  the real part i.e 1
print(c2.imag)				#print the imaginary part 2j

Boolean Values
Python supports another type called Boolean; a Boolean type can only be one of True or False
Example
all_ok = True
print(all_ok)			#O.p:- True
all_ok = False
print(all_ok)			#o.p:- False
print(type(all_ok))		#o.p:-Boolean

###############################################
#You can also convert strings into Booleans as long as the strings contain either True or False (and nothing else). 
status = bool (input ('OK it is confirmed: '))
print(status)					#o.p:- true
print(type(status))				#o.p:- true

Arithmetic Operators
Arithmetic operators are used to perform some form of mathematical operation such as addition, subtraction, multiplication and division etc. In Python they are represented by one or two characters.
Example
home = 10
away = 15
print(home + away) 			#o.p:- 1015
print(type(home + away))		#o.p:- string
print(10 * 4)				#o.p:- 40
print(type(10*4))			#o.p:- int
goals_for = 10
goals_against = 7
print(goals_for - goals_against)	#o.p:- 3	
print(type(goals_for - goals_against))		# o.p:- int

###########################################
However, you may notice that we have missed out division with respect to integers, why is this? It is because it depends on which division operator you use as to what the returned type actually is.
For example, if we divide the integer 100 by 20 then the result you might reasonably expect to produce might be 5; but it is not, it is actually 5.0:
Example
print(100 / 20)				#o.p;- 5
print(type(100 / 20))			#o.p:- int
##########################################
To ignore the fractional part then there is an alternative version of the divide operator //. This operator is referred to as the integer division operator
Example
print(100 // 20)		#o.p:- 5.0
print(type(100 // 20))		#o.p:- float

###########################################
But what if you are only interested in the remainder part of a division, the integer division operator has lost that? Well in that case you can use the modulus operation %
Example
print('Modulus division 100 % 13:', 100 % 13)		#o.p:- 9
print('Modulus division 3 % 2:', 3 % 2)			#o.p:- 1

##########################################
A final integer operator we will look at is the power operator that can be used to raise an integer by a given power, 
for example
5 to the power of 3. 
The power operator is '**'
a = 5
b = 3
print(a ** b)		#o.p:- 125

Assignment Operators
These assignment operators are actually referred to as compound operators  as they combine together a numeric operation  (such as add) with the assignment operator. 
 For example, the += compound operator is a combination of the add operator and the = operator 
example
x = 0
x += 1 # has the same behaviour as x = x + 1

!!!!!!!!!!!None Value
Python has a special type, the None Type, with a single value, None.
Example
winner = None
print(winner is None)		#o.p:- True
#Alternatively you can also write:
print(winner is not None)		#o.p:-False

#Which will print out True only if the
winner = None
print('winner:', winner)		#o.p:- winner: None
print('winner is None:', winner is None)		#o.p:- winner is None: True
print('winner is not None:', winner is not None)		#o.p:- winner is not None: False
print(type(winner))						#o.p:- <class 'NoneType'>
print('Set winner to True')					#o.p:- Set winner to True
winner = True

Flow of Control Using If Statements
Comparison Operators
Before exploring if statements we need to discuss comparison operators. These are operators that return Boolean values. They are key to the conditional elements of flow of control statements such as if. A comparison operator is an operator that performs some form of test and returns True of False.

Note that indentation, this is very important in Python; indeed, layout of the code is very, very important in Python. Indentation is used to determine how one piece of code should be associated with another piece of the code.
Example
num = int(input('Enter a number: '))
if num > 0:
print(num)					#o.p:- it  gives an error due to indentation

#######################################
#Now let us give the indentation
num = int(input('Enter a number: '))
if num > 0:
   print(num)					#o.p:- it give the user input to and check with it

#######################################
#Else in an If Statement
num = int(input('Enter yet another number: '))
if num < 0:
  print('Its negative')
else:
  print('Its not negative')

########################################
#The Use of elif
savings = float(input("Enter how much you have in savings: "))
if savings == 0:
   print("Sorry no savings")
elif savings < 500:
   print('Well done')
elif savings < 1000:
   print('Thats a tidy sum')
elif savings < 10000:
   print('Welcome Sir!')
else:
   print('Thank you')

Iteration/Looping
While Loop
The while loop exists in almost all programming languages and is used to iterative (or repeat) one or more code statements as long as the test condition (expression) is True



Example
count = 1
print('Starting')
while count <= 10:
    print(count)
    count+=1
  #o.p:- Starting
12345678910  
  
For Loop:- Loop over a set of values in a range
Example
print('Print out values in a range')
for i in range(2,10):
   print(i)
   print('Done')
#o.p:- Print out values in a range
2Done
3Done
4Done
5Done
6Done
7Done
8Done
9Done
Taking the input from the user

######################################
Example
print('Only print code if all iterations completed')
num = int(input('Enter a number to check for: '))
for i in range(0, 16):
    if i == num:
      break
    print(i)
    print('Done')
#o.p:-Only print code if all iterations completed
Enter a number to check for: 2
0Done
1Done

######################################
Now use an 'anonymous' loop variable
for _ in range(0,10):
   print('.', end='')
   print()
#o.p:- .
.
.
.
.
.
.
.
.
.
################################################
for _ in range(0,10):
   print('.', end='')		#o.p:- ..........

#Break Loop Statement
With the break statement we can stop the loop before it has looped through all the items:
print('Only print code if all iterations completed')
num = int(input('Enter a number to check for: '))
for i in range(0, 6):
   if i == num:
     break
   print(i, ' ', end='')
print('Done')
#o.p:- Only print code if all iterations completed
Enter a number to check for: 2
0  1  Done

#################################################
#location of print is changed
for i in range(0, 6):
   if i == num:
     break 
   print(i, ' ', end='')
   print('Done')
#o.p:- 0  Done
1  Done

##############################################
#Even number logic:-
for i in range(0, 10):
   #print(i, ' ', end='')
    if i % 2 == 1:
     continue
     print('hey its an even number')
     print('we love even numbers')
print('Done')
#o.p:- 0  1  2  3  4  5  6  7  8  9  Done

The continue Statement
With the continue statement we can stop the current iteration of the loop, and continue with the next:
Example
Do not print banana:
fruits = ["apple", "banana", "cherry"]
for x in fruits:
  if x == "banana":
    continue
  print(x)
#o.p:- apple
cherry

The range() Function
To loop through a set of code a specified number of times, we can use the range() function, The range() function returns a sequence of numbers, starting from 0 by default, and increments by 1 (by default), and ends at a specified number.
Example
Using the range() function:
for x in range(6):
  print(x)
#o.p:- 
0
1
2
3
4
5

#######################
Note that range(6) is not the values of 0 to 6, but the values 0 to 5.
The range() function defaults to 0 as a starting value, however it is possible to specify the starting value by adding a parameter: range(2, 6), which means values from 2 to 6 (but not including 6)
Example
Using the start parameter:
for x in range(2, 6):
  print(x)
#o.p:- 2
3
4
5
#####################################
The range() function defaults to increment the sequence by 1, however it is possible to specify the increment value by adding a third parameter: range(2, 30, 3):
Example
Increment the sequence with 3 (default is 1):
for x in range(2, 30, 3):
  print(x)
#o.p:- 2
5
8
11
14
17
20
23
26
29

Nested if_else :-
Write python code using nested if else.so as to check height as well as so as to allow for roller coster
example
print("Welcome to the roller coaster")
height=int(input("Please enter your height"))
age=int(input("Please enter your age "))
if height>=120:
    print("you can ride the roller coaster")
    if age<=18:
        print("your ticket will be 7$")
    else:
        print("your ticket will be 12$")
else:
    print("Sorry,you need to grow taller before you can ride")    
#o.p:-
Welcome to the roller coaster
Please enter your height23
Please enter your age 18
Sorry,you need to grow taller before you can ride

Nested if-elif statment :-
Write python code using   if elif.so as to check height as well as so as to allow for roller coster, using elif further you check age category and charge ticket accordingly
Example
print("Welcome to the roller coaster")
height=int(input("Please enter your height"))
if height>=120:
    print("you can ride the roller coaster")
    age=int(input("Please enter your age "))
    if age<12:
        print("your ticket will be 5$")
    elif age>12 and age<18:
        print("your ticket will be 7$")

    elif age>18:
        print("your ticket will be 12$")
else:
    print("Sorry,you need to grow taller before you can ride")    
#o.p:-
Welcome to the roller coaster
Please enter your height85
Sorry,you need to grow taller before you can ride
#we can put the input as per our requirements so the  answer is change so if the input are change

Iterators
numbers=[1,4,6]
value=numbers.__iter__()
item1=value._next__()
print(item1)			#o.p:-1
item2=value.__next__()
print(item2)			#o.p:-4
item3=value.__next__()
print(item3)			#o.p:-6

################################
num2=[6,8,2]
val=iter(num2)
itm1=next(val)
print(itm1)			#o.p:-6
itm2=next(val)
print(itm2)			#o.p:-8
itm3=next(val)
print(itm3)			#o.p:-2


















#Python Collection Types
Tuples 
A Tuple represents a collection of objects that are ordered and immutable (cannot be modified).
Syntax:- ( )

#####################################
Lists
Lists hold a collection of objects that are ordered and mutable (changeable), they are indexed and allow duplicate members.
Syntax :- [ ]

#####################################
Sets
Sets are a collection that is unordered and unindexed. They are mutable (changeable) but do not allow duplicate values to be held.
Syntax :- {}

####################################
Dictionary
A dictionary is an unordered collection that is indexed by a key which references a value. The value is returned when the key is provided.
Syntax :-{key : value}

#opertion on the tuple
Creating Tuples
tup1 = (1, 3, 5, 7)

###############################################
#Accessing Elements of a Tuple
print(f'tup1[0]:\t{tup1[0]}')
print('tup1[1]:\t', tup1[1])
print('tup1[2]:\t', tup1[2])
print('tup1[3]:\t', tup1[3])
#o.p :- tup1[0]:	1
tup1[1]:	 3
tup1[2]:	 5
tup1[3]:	 7

#############################################
#Tuples Can Hold Different Types
tup2 = (1, 'John',  True, -23.45)
print(tup2)
#o.p:- (1, 'John', True, -23.45)

#############################################
#Iterating Over Tuples
tup3 = ('apple', 'orange', 'plum', 'apple')
for x in tup3:
   print(x)
#o.p:- apple
orange
plum  apple

#################################################
#Tuple Related Functions
#You can also find out the length of a Tuple
len(tup3)
#o.p:-4

#################################################
#You can count how many times a specified value appears in a Tuple 
tup4 = ('apple', 'orange', 'plum', 'apple', 'apple')		# Tuples allow duplicates;
tup4.count('apple')
#o.p:-3

##############################################
#You can also find out the (first) index of a value in a Tuple:
print(tup4.index('apple'))		#o.p:-0
print(tup4.index('plum'))		#o.p:-2

##############################################
#Checking if an Element Exists
if 'orange' in tup3:
   print('orange is in the Tuple')			#o.p:- orange is in the Tuple

###############################################
#Nested Tuples
Tuples can be nested within Tuples; that is a Tuple can contain, as one of its elements, another Tuple.
tuple1 = (1, 3, 5, 7)
tuple2 = ('John', 'Denise', 'Phoebe', 'Adam')
tuple3 = (42, tuple1, tuple2, 5.5)
print(tuple3)		#o.p:- (42, (1, 3, 5, 7), ('John', 'Denise', 'Phoebe', 'Adam'), 5.5)

Note:-It is not possible to add or remove elements from a Tuple; they are immutable.








Lists
Lists are mutable ordered containers of other objects.
#opertion on the list
#Creating Lists
lst1 = ['John', 'Paul', 'George', 'Ringo']		#o.p:- lst1 = ['John', 'Paul', 'George', 'Ringo']

#################################################
#As with Tuples we can have nested lists and lists containing different types of elements.
lst1 = [1, 43.5, True]
lst2 = ['apple', 'orange', 31]
root_list = ['John', lst1, lst2, 'Denise']
print(root_list)		#o.p:- ['John', [1, 43.5, True], ['apple', 'orange', 31], 'Denise']

#################################################
#Accessing Elements from a List
lst1 = ['John', 'Paul', 'George', 'Ringo']
print(lst1[-1])					#o.p:- Ringo
lst1[-1]						#o.p:- 'Ringo'
lst1[-2]						#o.p:- 'George'

################################################
lst1 = ['John', 'Paul', 'George', 'Ringo']
print('lst1[1]:', lst1[1])				#o.p:- lst1[1]: Paul
print('lst1[-1]:', lst1[-1])			#o.p:- lst1[-1]: Ringo
print('lst1[1:3]:', lst1[1:3])			#o.p:- lst1[1:3]: ['Paul', 'George']
print('lst[:3]:', lst1[:3])				#o.p:- lst[:3]: ['John', 'Paul', 'George']
print('lst[1:]:', lst1[1:])				#o.p:-lst[1:]: ['Paul', 'George', 'Ringo']

###############################################
#Adding to a List:- append()
lst1 = ['John', 'Paul', 'George', 'Ringo']
lst1.append('Pete')
print(lst1)					#o.p:-['John', 'Paul', 'George', 'Ringo', 'Pete']

###############################################
#You can also add all the items in a list to another list. There are several options
lst1 = ['John', 'Paul', 'George', 'Ringo', 'Pete']
print(lst1)					#o.p:- ['John', 'Paul', 'George', 'Ringo', 'Pete']
#extend():- to add the more than one element in the list
lst1.extend(['Albert', 'Bob'])			#here, we can use the extend()
lst1						#o.p:- ['John', 'Paul', 'George', 'Ringo', 'Pete', 'Albert', 'Bob']

#############################################
#Inserting into a List
Sytanx:- list_name.insert(location _index_value,inserting_element_name )
a_list = ['Adele', 'Madonna', 'Cher']
print(a_list)					#o.p:- ['Adele', 'Madonna', 'Cher']
a_list.insert(1, 'Paloma')
print(a_list)					#o.p:-['Adele', 'Paloma', 'Madonna', 'Cher']
#############################################
#List Concatenation :- we can easily concatenate the list as like the concatenating the two string.
lst1 = [3, 2, 1]
lst2 = [6, 5, 4]
lst3 = lst1 + lst2
print(lst3)					#o.p:- [3, 2, 1, 6, 5, 4]
 
#############################################
#Removing from a List
another_lst = ['Gary', 'Mark', 'Robbie', 'Jason', 'Howard']
print(another_lst)			#o.p:- ['Gary', 'Mark', 'Robbie', 'Jason', 'Howard']
another_lst.remove('Robbie')
print(another_lst)			#o.p:- ['Gary', 'Mark', 'Jason', 'Howard']

#############################################
#The pop() Method
It removes an element from the List; however, it differs from the remove() method in two ways: It takes an index which is the index of the item to remove from the list rather than the object itself.
lst6 = ['Once', 'Upon', 'a', 'Time']
print(lst6)		#o.p:- ['Once', 'Upon', 'a', 'Time']
print(lst6.pop(2))	#o.p:-a
print(lst6)		#o.p:-['Once', 'Upon', 'Time']

#############################################
#Inserting into a List 
a_list = ['Adele', 'Madonna', 'Cher']
print(a_list)				#o.p:-['Adele', 'Madonna', 'Cher']
a_list.insert(1, 'Paloma')
print(a_list)				#o.p:-['Adele', 'Paloma', 'Madonna', 'Cher']

#######################
#List Concatenation
list1 = [3, 2, 1]
list2 = [6, 5, 4]
list3 = list1 + list2			#here the 2 list are added
print(list3)				#o.p:- [3, 2, 1, 6, 5, 4]

##############################################
#clear removes all the elements from the list
lst=["cherry","banana","apple"]
lst.clear()
print(lst)

##############################################
#copy() method
lst=["cherry","banana","apple"]
lst2=lst.copy()
print(lst2)				#o.p:- the same another list is made

############################################

# Reverse  :-it is used to reveres the list
lst=["cherry","cherry","banana"]
lst.reverse()
print(lst)

###########################################
#sort() :-Sort the list alphabetically
lst=["cherry","orange","banana"]
lst.sort()
print(lst)

##########################################
#multiplying all the element from the list
lst=[1,23,12,3]
mul1=1
for i in lst:			# accessing the element from the list
    mul1=mul1*i
print(mul1)

###########################################
Write a method that takes in an integer n ,then iterates through all the numbers from 0 to n,return the sum of numbers which are divisible by 5 or 7
lst=[1,2,5,7,14,55,45,21,49,8,9]
def return_sum(lst):
    sum=0
    for i in range(len(lst)):
        if(lst[i]%5==0 or lst[i]%7==0):
            sum=sum+lst[i]
    return sum

print(return_sum(lst))        

########################################




Set
Set operation
Creating a Set
Example 
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket)				#o.p :- {'apple', 'pear', 'banana', 'orange'}
#####When run this code will show that apple is only added once to the set:

##############################################
#Accessing Elements in a Set
for item in basket:
   print(item)
#o.p:- apple
pear
banana
orange
##############################################
#Adding Items to set
basket = {'apple', 'orange', 'banana'}
basket.add('apricot')
print(basket)				#o.p:- {'apricot', 'apple', 'banana', 'orange'}

##############################################
#If you want to add more than one item to a Set you can use the update() method:
basket = {'apple', 'orange', 'banana'}
basket.update(['apricot', 'mango', 'grapefruit'])
print(basket)				#o.p:- {'apple', 'grapefruit', 'apricot', 'orange', 'mango', 'banana'}

#############################################
#Obtaining the Length of a Set
basket = {'apple', 'orange', 'apple', 'pear', 'orange','banana'}
print(len(basket))			#o.p:- 4

############################################
#Obtaining the Max and Min Values in a Set
basket2={23,45,67,12,456}
print(max(basket2))			#o.p:-456
print(min(basket2))			#o.p:-12

###########################################
#Removing an Item
basket = {'apple', 'orange', 'apple', 'pear', 'orange','banana'}
print(basket)				#o.p:- {'apple', 'pear', 'banana', 'orange'}
basket.remove('apple')			#o.p:- {'banana', 'orange', 'pear'}
basket.discard('apricot')		#o.p:- {'apple', 'pear', 'banana', 'orange'}
print(basket)				#o.p:- {'pear', 'banana', 'orange'}

###########################################
#Set Operations
s1 = {'apple', 'orange', 'banana'}
s2 = {'grapefruit', 'lime', 'banana'}
print('Union:', s1 | s2)			#o.p:- Union: {'orange', 'apple', 'grapefruit', 'banana', 'lime'}
print('Intersection:', s1 & s2)		#o.p:- Intersection: {'banana'}
print('Difference:', s1 - s2)		#o.p:- Difference: {'apple', 'orange'}

############################################################

Dictionaries
A Dictionary is a set of associations between a key and a value that is unordered,changeable (mutable) and indexed.
Operation on the Dictionaries
Definattion of the Dictionaries
capitals = {
'Maharashtra': 'Mumbai',
'Gujrat': 'Ahmadbad',
'UP': 'Lakhnow',
'Karnataka': 'Banglore',
'Andhrapradesh': 'Hydrabad' }
print(capitals)	#o.p:- {'Maharashtra': 'Mumbai', 'Gujrat': 'Ahmadbad', 'UP': 'Lakhnow', 'Karnataka': 'Banglore', 'Andhrapradesh': 'Hydrabad'}

##############################################
#Accessing Items via Keys
print('capitals[Maharashtra]:', capitals['Maharashtra'])		#o.p:- capitals[Maharashtra]: Mumbai

#############################################
#Adding a New Entry
capitals['West_Bengal']='Kolkatta'
capitals
#o.p;- {'Maharashtra': 'Mumbai',
 'Gujrat': 'Ahmadbad',
 'UP': 'Lakhnow',
 'Karnataka': 'Banglore',
 'Andhrapradesh': 'Hydrabad',
 'West_Bengal': 'Kolkatta'}

#############################################
#Changing a Keys Value
capitals['Gujrat'] = 'Gandhinagar'
print(capitals)
#o.p:- {'Maharashtra': 'Mumbai', 'Gujrat': 'Gandhinagar', 'UP': 'Lakhnow', 'Karnataka': 'Banglore', 'Andhrapradesh': 'Hydrabad', 'West_Bengal': 'Kolkatta'}

#############################################
#Removing an Entry
capitals.pop('Karnataka')
print(capitals)
#o.p:- {'Maharashtra': 'Mumbai', 'Gujrat': 'Gandhinagar', 'UP': 'Lakhnow', 'Andhrapradesh': 'Hydrabad', 'West_Bengal': 'Kolkatta'}

############################################
#del key word to delete the element by using the key value
del capitals['UP']
print(capitals)
#o.p:- {'Maharashtra': 'Mumbai', 'Gujrat': 'Gandhinagar', 'Andhrapradesh': 'Hydrabad', 'West_Bengal': 'Kolkatta'}

############################################
#Iterating over Keys
capitals = {
'Maharashtra': 'Mumbai',
'Gujrat': 'Ahmadbad',
'UP': 'Lakhnow',
'Karnataka': 'Banglore',
'Andhrapradesh': 'Hydrabad'
}
for states in capitals:
   print(states, end=', ')		#o.p:- Maharashtra, Gujrat, UP, Karnataka, Andhrapradesh,
##########################################

for states in capitals:
     print(states, end=', ') 
     print(capitals[states])
#o.p:- for states in capitals:
     print(states, end=', ') 
     print(capitals[states])

###############################################
#Values, Keys and Items
print(capitals.values())	#o.p:-dict_values(['Mumbai', 'Ahmadbad', 'Lakhnow', 'Banglore', 'Hydrabad'])
print(capitals.keys())		#o.p:-dict_keys(['Maharashtra', 'Gujrat', 'UP', 'Karnataka', 'Andhrapradesh'])
print(capitals.items())	#o.p:- dict_items([('Maharashtra', 'Mumbai'), ('Gujrat', 'Ahmadbad'), ('UP', 'Lakhnow'), ('Karnataka', 'Banglore'), ('Andhrapradesh', 'Hydrabad')])

###############################################
#Checking Key Membership
print('Karnataka' in capitals)		#o.p:- True
print('Bihar' not in capitals)		#o.p: True

#############################################
#Obtaining the Length of a Dictionary
print(len(capitals))				#o.p:- 5

############################################
#Dictionaries can have values in tuple
seasons = {'Summer': ('Feb','Mar', 'Apr', 'May'),
'Rainy': ('June', 'July', 'August','Sept'),
'Winter': ( 'Oct','Nov','December', 'January')}
print(seasons['Rainy'])			#o.p:- ('June', 'July', 'August', 'Sept')
print(seasons['Rainy'][1])			#o.p:- July

##########################################
#Dictionary Methods
get() is a useful method to access the values of a key in a dictionary.
print(capitals.get('UP'))			#o.p:- Lakhnow

##########################################
#Duplicates Not Allowed
Dictionaries cannot have two items with the same key:
dict2 = {
  "brand": "Maruti",
  "model": "Breeza",
  "year": 2021,
  "year": 2020
}
print(dict2)
#o.p:- {'brand': 'Maruti', 'model': 'Breeza', 'year': 2020}

############################################
#Loop Through a Dictionary, it will show only keys
for x in dict2:
  print(x) 
#o.p:- brand
model
year

##########################################
#Print all values in the dictionary, one by one:
for x in dict2:
  print(dict2[x]) 
#o.p:- Maruti
Breeza
2020

#########################################
#You can also use the values() method to return values of a dictionary:
for x in dict2.values():
  print(x) 
#o.p:- Maruti
Breeza
2020

##########################################
#you can use the keys() method to return the keys of a dictionary:
for x in dict2.keys():
  print(x) 
#o.p:- brand
model
year

############################################
#Loop through both keys and values, by using the items() method:
for x, y in dict2.items():
  print(x, y) 
#o.p :-brand Maruti
model Breeza
year 2020

#############################################
#Copy a Dictionary
Make a copy of a dictionary with the copy() method:
mydict = dict2.copy()
print(mydict)		#o.p:- {'brand': 'Maruti', 'model': 'Breeza', 'year': 2020}

############################

#Write a Python script to add a key to a dictionary. 
#Sample Dictionary : {0: 10, 1: 20}
#Expected Result : {0: 10, 1: 20, 2: 30}

d = {0:10, 1:20}
print(d)                #o.p:-{0: 10, 1: 20}
d.update({2:30})
print(d)                #o.p:-{0: 10, 1: 20, 2: 30}

############################################
#adding the value to the dictionary
d = {0:10, 1:20}
print(d)            #o.p:-{0: 10, 1: 20}
d[2]=30             #adding by using index value
print(d)            #o.p:-{0: 10, 1: 20, 2: 30}

##############################################
‘’’Write a Python script to concatenate the following dictionaries to create a new one.
Sample Dictionary :
dic1={1:10, 2:20}
dic2={3:30, 4:40}
dic3={5:50,6:60}
Expected Result : {1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60}
'''
dic1={1:10, 2:20}
dic2={3:30, 4:40}
dic3={5:50,6:60}
dic4 = {}
for d in (dic1, dic2, dic3): dic4.update(d)
print(dic4)         #o.p:-{1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60}

################################################
#Write a Python script to check whether a given key already exists in a dictionary. 
d = {1: 10, 2: 20, 3: 30, 4: 40, 5: 50, 6: 60}
def is_key_present(x):
  if x in d:
      print('Key is present in the dictionary')
  else:
      print('Key is not present in the dictionary')
is_key_present(5)
is_key_present(9)
#o.p:-Key is present in the dictionary
#o.p:-Key is not present in the dictionary

###################################################
#Write a Python program to iterate over dictionaries using for loops. 
d = {'x': 10, 'y': 20, 'z': 30} 
for dict_key, dict_value in d.items():
    print(dict_key,':',dict_value)
'''#o.p:-x : 10
y : 20
z : 30'''

#####################################################
'''Write a Python script to generate and print a dictionary that contains a number (between 1 and n) in the form (x, x*x).
Sample Dictionary ( n = 5) :
Expected Output : {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}'''
n=int(input("Input a number "))
d = dict()
for x in range(1,n+1):
    d[x]=x*x
print(d) #o.p:-Input a number 5
#o.p:-{1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

###############################################
#Write a Python script to merge two Python dictionaries. 
def merge_dictionaries(*dicts):
  result = dict()
  for d in dicts:
    result.update(d)
  return result
#Let us define first dictionory
students1 = {
  'Theodore': 10,
  'Mathew': 11,
}
#The second dictionory
students2 = {
  'Roxanne': 9
}
print("Original dictionaries:")
print(students1)
print(students2)
print("\nMerge dictionaries:")
print(merge_dictionaries(students1, students2))
'''o.p:-Original dictionaries:{'Theodore': 10, 'Mathew': 11}{'Roxanne': 9}
Merge dictionaries:{'Theodore': 10, 'Mathew': 11, 'Roxanne': 9}'''

################################################
#Write a Python program to sum all the items in a dictionary. 
my_dict = {'data1':100,'data2':-54,'data3':247}
print(sum(my_dict.values()))        #o.p:-293

################################################
#Write a Python program to multiply all the items in a dictionary.
my_dict = {'data1':100,'data2':-54,'data3':247}
result=1
for key in my_dict:    
    result=result * my_dict[key]
print(result)       #o.p:--1333800

############################
#Write a Python program to remove a key from a dictionary.
myDict = {'a':1,'b':2,'c':3,'d':4}
print(myDict)
if 'a' in myDict: 
    del myDict['a']
print(myDict)
'''o.p:-{'a': 1, 'b': 2, 'c': 3, 'd': 4}
{'b': 2, 'c': 3, 'd': 4}'''

#############################################
#Write a Python program to map two lists into a dictionary. 
keys = ['red', 'green', 'blue']
values = ['#FF0000','#008000', '#0000FF']
color_dictionary = dict(zip(keys, values))
print(color_dictionary)
'''o.p:-{'red': '#FF0000', 'green': '#008000', 'blue': '#0000FF'}'''

############################################
#Write a Python program to sort a given dictionary by key. 
color_dict = {'red':'#FF0000',
          'green':'#008000',
          'black':'#000000',
          'white':'#FFFFFF'}

for key in sorted(color_dict):
    print("%s: %s" % (key, color_dict[key]))
'''o.p:-black: #000000
green: #008000
red: #FF0000
white: #FFFFFF'''

##############################################
#Write a Python program to get the maximum and minimum values of a dictionary.
my_dict = {'x':500, 'y':5874, 'z': 560}
key_max = max(my_dict.keys(), key=(lambda k: my_dict[k]))
key_min = min(my_dict.keys(), key=(lambda k: my_dict[k]))
print('Maximum Value: ',my_dict[key_max])       #o.p:-Maximum Value:  5874
print('Minimum Value: ',my_dict[key_min])       #o.p:-Minimum Value:  500

###############################################
#Write a Python program to print all distinct values in a dictionary.
L = [{"V":"S001"}, {"V": "S002"}, {"VI": "S001"}, {"VI": "S005"}, {"VII":"S005"}, {"V":"S009"},{"VIII":"S007"}]
print("Original List: ",L)
u_value = set( val for dic in L for val in dic.values())
print("Unique Values: ",u_value)
'''o.p:-Original List:  [{'V': 'S001'}, {'V': 'S002'}, {'VI': 'S001'}, {'VI': 'S005'}, {'VII': 'S005'}, {'V': 'S009'}, {'VIII': 'S007'}]
Unique Values:  {'S005', 'S007', 'S001', 'S009', 'S002'}'''

###############################################
#Write a Python program to find the highest 3 values of corresponding keys in a dictionary. 
from heapq import nlargest
my_dict = {'a':500, 'b':5874, 'c': 560,'d':400, 'e':5874, 'f': 20}  
three_largest = nlargest(3, my_dict, key=my_dict.get)
print(three_largest) 
#o.p:-['b', 'e', 'c']

###############################################
#Dictionary methods
#clear():Remove all elements from the car list
car = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
car.clear()
car

#####################################
#copy method
car = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
x = car.copy()
print(x)

####################
#fromey()
#Create a dictionary with 3 keys, all with the value 0
x={'key1','key2','key3'}
y=0
thisdict=dict.fromkeys(x,y)
thisdict

#warmup question
#revere the word
def reverse_words(input):
    if input=="":
        return "You have entered wrong input"
    else:
        words=input.split()
        reverse_sentence="  ".join(reversed(words))
    return reverse_sentence
print(reverse_words("This is India"))

#another way
def reverse(input):
    if input=="":
       return "you have entered wrong input"
    else:
        string=input[::-1]
    return string
print(reverse("This"))

###########################################
#value found in the list or not
lst=[10,20,30,700,80,45]
def search(lst,value):
    for i in range(len(lst)):
        if lst[i]==value:
           return "The value has been found at position  {}".format(i)
    return " Value not found"  
print(search(lst,12))   
#o.p:- Value not found

##################################################
write python code to find fibbonacy series
def fibbo(n):
        lst=[]
        previous=0
        current=1
        lst.append(current)
        for i in range(n-1):
            previous,current=current,previous+current 
            lst.append(current)
        return lst    
print(fibbo(8))

###########################################################
def fibbo(n):
    lst=[]
    previous=0
    current=1
    lst.append(current)
    for i in range(n-1):
        previous,current=current,previous+current
        lst.append(current)
    return lst    
print(fibbo(8))
###########################################################
cities=["Mumbai","New york","Paris"]
countries=["India","USA","France"]
z=zip(cities,countries)
z
for i in z:
    print(i)
d={city:country for city,country in zip(cities,countries)}
print(d)
#Write a program  that takes a string and return the number of vowels regardless of case sensitivity
def count_vovwels(input):
    #initialize the counter
    count=0
    #for letter in input
    for i in range(len (input)):
        #get the character from input and convert to lower case
        choice=input[i]
        current=choice.lower()
        #current=input.lower()[i]
        if(current=='a' or current=='e' or current=='i' or current=='o' or current=='u'):
            count=count+1
    return count 
print(count_vovwels('AEIOU'))       
###############################################################
#pipe operator in the case
match input("Are you sure ? (y/n):"):
case "y":
    print("Done")
case "n":
    print("cancelled")
case cmd:
    print("Unknown command",cmd)

###############################################################
********************file handling************************
#for opening the file first we need to check the working dirtectory
#abstract path:-	'c:/10-python/pi_digits.txt'
#relative path:-	'pi_digits.txt'

with open('pi_digits.txt') as file_object:
    #The open() function needs
    #one argument: the name of the file you want to open.
    contents = file_object.read()
print(contents)

#############################################################
#Observe the extra line at the end of output
#To avoid this rstrip() method is used
with open('pi_digits.txt') as file_object:
    contents = file_object.read()
print(contents.rstrip())
#rstrip() method removes, or strips, any whitespace
#characters from the right side of a string.

#############################################################
file_path ='c:/10-python/pi_digits.txt'
with open(file_path) as file_object:
    contents = file_object.read()
print(contents.rstrip())

############################################################
#Reading Line by Line
filename = 'pi_digits.txt'
#we assign the name of the file we’re reading from to the variable
with open(filename) as file_object:
#We again use the with syntax to let Python open and close the file properly.
    for line in file_object:
       print(line)

######################################################
#These blank lines appear because an invisible newline character is at the end of each line in the text file. Using rstrip() on each line in the print() call eliminates these extra blank lines:
filename = 'pi_digits.txt'
with open(filename) as file_object:
     for line in file_object:
        print(line.rstrip())

#########################################################
#Making a List of Lines from a File When you use with, the file object returned by open()  is only available inside the with block that contains it. If you want to retain access to a file’s contents outside the with block,  you can store the file’s lines in a list  inside the block and then work with that list.
filename = 'pi_digits.txt'
with open(filename) as file_object:
   lines = file_object.readlines()#file object is converted to list
#the readlines() method takes each line from the file 
#and stores it in a list.
for line in lines:
    print(line.rstrip())

#############################################################
#Working with a File’s Contents After you’ve read a file into memory,  you can do whatever you want with that data
filename = 'pi_digits.txt'
with open(filename) as file_object:
    lines = file_object.readlines()
    pi_string = ''
    for line in lines:
      pi_string += line.rstrip()
      print(pi_string)
      print(len(pi_string))

#############################################################
#Writing to a File One of the simplest ways to save data is to write it to a file. When you write text to a file,  the output will still be available after  you close the terminal containing your program’s output.
filename = 'programming.txt'
with open(filename, 'w') as file_object:
    file_object.write("I love programming.")

#########################################################
#Writing Multiple Lines The write() function doesn’t add any newlines to the text you write. So if you write more than one line without including newline characters 
Filename = 'programming.txt'
with open(filename, 'w') as file_object:
   file_object.write("I love programming.")
   file_object.write("I love creating new games.")

##########################################################
#Including newlines in your calls to write() makes  each string appear on its own line
filename = 'programming.txt'
with open(filename, 'w') as file_object:
    file_object.write("I love programming.\n")
    file_object.write("I love creating new games.\n")

#########################################################
#Appending to a File If you want to add content to a file  instead of writing over existing content you can open the file in append mode. When you open a file in append mode, Python doesn’t erase the contents of the file  before returning the file object.
filename = 'programming.txt'
with open(filename, 'a') as file_object:
#we use the 'a' argument to open the file for appending
# rather than writing over the existing file.
    file_object.write("I also love finding meaning in large datasets.\n")
    file_object.write("I love creating apps that can run in a browser.\n")






"""------------------------------------------Exception handling-----------------------------"""
The error signifies a sitution that mostly happen  due to the absenceof the system resoursethe exception are the issue that can be appear at run time and compile time it majority occure in tha code or program authoriesd by the devloper
#Exception are sovled by the try and exception block performallity it can make the code less  error free
try:
    print(5/0)
except ZeroDivisionError:
    print(" you cannot dive by zero")
#o.p:- you cannot dive by zero

########################################################
#Taking the input from  the user  take the correct iinput and avilablity of the program
print("give me two number and i will solve it")
print("enter the 'q' to quit")
while True:
    first_num=input("enter the 1st num")
    if first_num=='q':
        break
    second_num=input("enter the 2nd num")
    if second_num=='q':
        break
    answer=int(first_num)/int(second_num)
    print(answer)

########################################################
#Handling  the filenotfound error exception the file are not are avilable
filename='alice.txt'
with open(filename ,encoding='utf-8') as f:
    content=f.read()
#########################################################
#it is solve by using the try and exception block
filename='alice.txt'
try:
    with open(filename ,encoding='utf-8') as f:
        content=f.read()
except FileNotFoundError:
    print("sorry the file not found")




***********************Function***********************
#Why to Write Functions?
#When you are writing a program if you find yourself writing the same code more than once, it is probably best to define a function with the repeated code in it.

#passing the num as the default function 
def prime_num(num):
    for i in range(2,num):
        if (num%i==0):
            return "The number is not prime"
            break
    return "The number is prime"
print(prime_num(12))			#o.p:-The number is not prime

######################################################
#arbitary function -> passing the num as the arbitary function
num=int(input('enter the number:-'))
def prime_num():
    for i in range(2,num):
        if (num%i==0):
            return "The number is not prime"
            break
    return "The number is prime"
print(prime_num())			#o.p:- as per user enter the number

######################################################
#"""Display a simple greeting."""
def greet_user():
 print("Hello!")
greet_user()				#o.p:-Hello!

####################################################
#Passing Information to a Function
def greet_user(username):
#Display a simple greeting."""
   print(f"Hello, {username}!")
   
greet_user('Sanjivani AI')		#o.p:-Hello Sanjivani AI 

##################################################
#Arguments and Parameters
#The variable username in the def of greet_user() is an example of a
def describe_pet(animal_type, pet_name):
#Display information about a pet.
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name}.")
describe_pet('Dog', 'Moti')	#o.p:- I have a Dog.
My Dog's name is Moti.
#Order Matters in Positional Arguments

describe_pet('Moti', 'Dog')		#o.p:- I have a Moti.
My Moti's name is Dog.

####################################################
#Default Values
#When writing a function, you can define a default value for each parameter.
def describe_pet(pet_name, animal_type='dog'):
#Display information about a pet.
   print(f"\nI have a {animal_type}.")
   print(f"My {animal_type}'s name is {pet_name.title()}.")
describe_pet(pet_name='Moti')		#o.p:- I have a dog.
My dog's name is Moti.

#####################################################
#Avoiding Argument Errors
def describe_pet(animal_type, pet_name):
#Display information about a pet.
  print(f"\nI have a {animal_type}.")
  print(f"My {animal_type}'s name is {pet_name.title()}.")
describe_pet()

#####################################################
#Return Values
def get_formatted_name(first_name, last_name):
#Return a full name, neatly formatted.
   full_name = f"{first_name} {last_name}"
   return full_name
musician = get_formatted_name('Ram', 'Sarkar')
print(musician)					#o.p:- Ram Sarkar

#####################################################
#Returning a Dictionary
def build_person(first_name, last_name):
#Return a dictionary of information about a person."""
   person = {'first': first_name, 'last': last_name}
   return person
musician = build_person('Ram', 'Sarkar')
print(musician)				#o.p:- {'first': 'Ram', 'last': 'Sarkar'}

######################################################


#Passing a List
#You’ll often find it useful to pass a list to a function, whether it’s a list of names, numbers, or more complex objects, such as dictionaries.
def greet_users(names):
#Print a simple greeting to each user in the list."""
    for name in names:
        msg = f"Hello, {name.title()}!"
        print(msg)
usernames = ['Sanket', 'Saurabh', 'Surabhi']
greet_users(usernames)
#o.p:- Hello, Sanket!
Hello, Saurabh!
Hello, Surabhi!

#########################################################
#Passing an Arbitrary Number of Arguments
def make_pizza(*toppings):
#Print the list of toppings that have been requested."""
    print(toppings)
make_pizza('pepperoni')
make_pizza('mushrooms', 'green peppers', 'extra cheese')
#o.p:- ('pepperoni',)
('mushrooms', 'green peppers', 'extra cheese')

#########################################################
#Now we can replace the print() call with a loop that runs through the list of toppings and describes the pizza being ordered:
def make_pizza(*toppings):
#Summarize the pizza we are about to make."""
   print("\nMaking a pizza with the following toppings:")
   for topping in toppings:
       print(f"- {topping}")

make_pizza('pepperoni')
make_pizza('mushrooms', 'green peppers', 'extra cheese')
#o.p:- Making a pizza with the following toppings:
- pepperoni
Making a pizza with the following toppings:
- mushrooms
- green peppers
- extra cheese

#####################################################



#Mixing Positional and Arbitrary Arguments
def make_pizza(size, *toppings):
#Summarize the pizza we are about to make."""
   print(f"\nMaking a {size}-inch pizza with the following toppings:")
   for topping in toppings:
       print(f"- {topping}")
make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
#o.p:- Making a 16-inch pizza with the following toppings:
- pepperoni
Making a 12-inch pizza with the following toppings:
- mushrooms
- green peppers
- extra cheese

################################################
import pizza
pizza.make_pizza(16, 'pepperoni')
pizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')

##################################################
#importing Specific Functions
from pizza import make_pizza
make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')

####################################################
#Using as to Give a FunctionS an Alias
from pizza import make_pizza as mp
mp(16, 'pepperoni')
mp(12, 'mushrooms', 'green peppers', 'extra cheese')

#######################################################
#Using as to Give a Module an Alias
import pizza as p
p.make_pizza(16, 'pepperoni')
p.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')

#######################################################
#Importing All Functions in a Module
from pizza import *
make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')

#scope of variable
x=x+1
x=6
print(x)
#You cannot reference a variable 
#until it has been assigned a value.





************************Working with JSON File*********************
#JSON:-Java Script object notation
Storing the data in the jason file it is important for futur work using the json.dump() and json.load
Json.dump():- dumps takes an object and produces a string
Json.load():-  load would take a file _like object read the data from that object and use that string to create an object
import json
number = [2,3,4,5,6,74,34]
file_name='number.json'
with open(file_name,'w') as obj:
    json.dump(number,obj)
#o.p:- the file are created in the working directory 
The nmber are written in the file

######################################################
# saving the data with json file working with user generated  data
import json
username=input("enter the name")
file_name='username.json'
with open(file_name,'w') as obj:
    json.dump(username,obj)
print(f"iwill remmebre you when you come back ,{username}!")
#f:-This is called f string and are quite 
Straight forword :when using on f’ in front of a string all the variable inside curly bracket are read and replaced by there value

#####################################################
# Now lets write new program  that generat user name is alerady has been stored
import json 
file_name ='username.json'
with open(file_name) as obj:
    username=json.load(obj)
print(f"welcome back,{username}!")
#writing the username i.e. '{username}!'
#o.p:- It will rember the preseviosly user name who acess the file

####################################################
# combine two program in one program with the exception handling
#load the username if it has been stored previsoly otherwise promt for the user name and stored it
import json
file_name= 'username.json'
try:
    with open(file_name) as obj:
        username=json.load(obj)
except FileNotFoundError:
    username=input("enter the name")
    file_name='username.json'
    with open(file_name,'w') as obj:
        json.dump(username,obj)
    print(f"iwill remmebre you when you come back ,{username}!")
else:
    print(f" welcome back,{username}!")





******************operation on list i.e list comprehension**************
#append :  IT can add the element  at last of the list 
lst=[]
for num in range(0,20):
    lst.append(num)
print(lst)
#o.p:-[0,1,2,3,……..,19]

############################################################
	List Comprehension:-
1.We can write same methods using the list comprehension
2.Comprehension can reduce the line of the codes
3. systax=[ write the lines of for condition]
#4. Comprehension:-comprehension in the python orovides us with a short and concise way to construt
			 New sequence using the sequence with have been alredy  defined
#Methodes using the list comprehension
IMP One Question for In interview

lst=[num for num in range(0,20)]
print(lst)		#o.p:-[0,1,2,3,……..19]

############################################################
Capitalize:-every first letter will be captalize of word call the methood along with the name of the list
Example:-
name=['dada','kaka','mama']
lst=[name.capitalize() for name in name]
print(lst)					#o.p:- ['Dada', 'Kaka', 'Mama']

###########################################################
list comrehension with 'if' statement
#'if' should be right side of the for loop. write the  code in  the suitable format we use the it statement  and another way is also present i.e in one line
def is_even(num):
    return num%2==0
lst=[
     num
     for num in range(10)
     if is_even(num)
     ]
print(lst)
#o.p:- [0,2,4,6,8]

###########################################################
Above code are written  in the one line by using the  list comprehension
def is_even(num):
    return num%2==0
lst=[ num for num in range(10) if is_even(num)]
print(lst)					#o.p:-[0,2,4,6,8]

#####################################
list comrehension to print a particular digit
lst=[f"{x}{y}"
      for x in range(3)
      for y in range(3)
      ]
print(lst)	#o.p:- ['00', '01', '02', '10', '11', '12', '20', '21', '22']
#can print the number in the particular digit . it has another part also as like the nested for loop

######################################################
1)set comprehension:-
#set comprehension are pretty similar to list comprehension .The only Difference between them is that set comprehension are  in the curly bracket {}. Not allow the duplicate element. It give the result in the form of set only Key are index of the number
lst={x
     for x in range(3)
     }
print(lst)		#o.p:- {0, 1, 2}

########################################################
2) Dictionary comprehension
# give the result in the form of the dictionary it give the key as well as value we process on the value rather than the key component
#syntax:- output_dict={Key:value or(key,value) in iterable if(key,value statisfy thi condition)}
dict={x:x*x
     for x in range(3)
     }
print(dict)				#o.p:- {0: 0, 1: 1, 2: 4}

##############################################################
Generator
#It is another way of creating the iterator in the simple way where  it uses the keyword “yield” instead of returing it in a defined function genterated are implemented using the a function
gen=(x
     for x in range(3)
     )
print(gen)			#gen is the object
for num in gen:
    print(num)			#o.p:-0,1,2
#(): object

###############################################################
Next
#it give the line by line output generted object:- generated function return a generator object Generated object are used either by calling the next method on the generator object  or using the genertoor object in the “for in loop”
gen=(x 
     for x in range(3)
     )
next(gen)			#o.p:-0

#########################################################
gen=(x for x in range(3))
next(gen)		#o.p:-0
next(gen)		#o.p:-1
#the last output give the answer as 1

#####################################################
gen=(x for x in range(3))
next(gen)			#o.p:-0
next(gen)			#o.p:-1
next(gen)			#o.p:-2
next(gen)			#o.p:-error out of the loop

######################################################
#Yield:-access the multipele value by using the yield
def range_even(end):
    for num in range(0,end,2):
        yield num			#above are definition of the function
for num in range(6):
    print(num)				#o.p:-0,1,2,3,4,5

######################################################    
Now  next insted of the for loop
gen=range_even(16)
next(gen)      				 #o.p:-0
next(gen)   				#O.p:- 2
next(gen)   				#o.p:-4
next(gen)   				#o.p:-6
next(gen)   				#o.p:-8
#o.p:-8

######################################################
Application of the generator
Generator function are defined like a normal function but whenever it needs to generate a value
It close so with the yield keyword rather that return 
If the body of a def contains yield the function automatically becomes a generator function 
1 chaining generator:-  chain the various function
def length(itr):
    for ele in itr:
        yield len(ele)
def hide(itr):
    for ele in itr:
        yield ele*'*'
passwords=["not good","given'm pass","00100=100"]
for password in hide(length(passwords)):
    print(password)
#o.p:- ********
************
*********
# it can count the length of the password and print the * instend of the character

#####################################################
Printing the list with index
Here we can increment the index value with 1 becz of the index start with the 0 index It can make the space between the index value and list element It can print the elemnt of the list with there index value
lst=["milk","egg","bread"]
for index in range(len(lst)):
    print(f"{index+1} - {lst[index]}")   
#o.p:- 1 - milk
2 - egg
3 – bread

#######################################################
Assigment day 
# adjectives= name of adjective
#noun=name of the noun
#password=join the all strig
import string
adjectives=['sleepy','slow','smelly','wet','fat','red','orange']		#pick the adjectives
noun=['apple','dinosor','ball','toaster','goat','dragon','hammer','dduck','panda']	#pick the noun
import random			#pick the words randomly
adjectives=random.choice(adjectives)
noun=random.choice(noun)
number=random.randrange(0,100)		#selcte the number
special_char=random.choice(string.punctuation)	#sleect the special character
password=adjectives+noun+str(number)+special_char		#create the new secure password
print('your new password is:-%s'% password)
#%s:-
print(f'your new password is:- {password}')

####################################################
# another  way is also to generate the password u can use the while loop also and if condition
#responce=taking the input from the user in the below program it can give the another password also if you are not statistified with  inlial one
print("wlecome back to password picker")
while True:
    adjectives=random.choice(adjectives)
    noun=random.choice(noun)
    number=random.randrange(0,100)
    special_char=random.choice(string.punctuation)
    password=adjectives+noun+str(number)+special_char
    print(f'your new password is:-{password}')
    responce=input('would you want too enter the new password type y or n:-')
    if responce=='n':
        break
   # else:
    #    continue

##########################################################
# take input from user for password and check for the generated password is good or bad
noun=[]
adj=[]
import string
import random
while True:
    n=input(' enter the list of the noun with start with the  capital letter :-')
    noun.append(n)
    a=input(" enter the list of the adjectives with start with the capital letter:-")
    adj.append(a)
    responce=input('would you want too append the list ao adj or noun (type y or n):-')
    if responce=='n':
        break
print(noun)
print(adj)
adj=random.choice(adj)
noun=random.choice(noun)
number=random.randrange(0,100)
special_char=random.choice(string.punctuation)
password=adj+noun+str(number)+special_char
print(f'your new password is:-{password}')
def pass_word(password): #defining the function 
     for x in password:
         if x>="A" and x<="Z":
             has_upper=True
         elif x>="a" and x<="z":
             has_lower=True
         elif x>="0" and x<="9":
             has_num=True
     if len(password)>=8 and has_upper and has_lower and has_num:
         return True
     else:
         return False
#t= input("enter the password:-")
if pass_word(password):        # checkpassword:-is the function that can check the password
     print("Good password")
else:
     print("Bad password")
 






Enumerate
1.enumerate methods add a counter to an iterable and returns if in a from of enumerating object
2. this enumerate object can be used drirectly for loops or converted into a list of tuples using the list function
3.Syntax:- enumerate(iterable ,start=0)
Iterable:- any object that support iteration
Start:- the index from  which the counter is to be started ,by default it is 0

#same code can be implemented using enumerate:-
for index,item in enumerate(lst,start=1):
    print(f"{index} {item}")
#o.p:- 1 - milk
2 - egg
3 – bread

############################################################
#zip:-Use of zip function with the mis-match function
name=['dada' ,'mama', 'kaka']
info=[9850,6032,9785] 
for nm, inf in zip (name, info):
    print (nm, inf)
#o.p:- dada 9850
mama 6032
kaka 9785

#########################################################
#Use of zip function with mis match list
name= ['dada', 'mama',' kaka', 'baba']
info= [9850,632,9785] 
for nm, inf in zip (name, info):
    print (nm, inf)  
#o.p:- dada 9850
mama 632
 kaka 9785  
 #It will not display excess mismatch item in name I .e. baba   

##############################
#zip_longest :- It print  the values of iterables alternately in sequence. If one of the iterables is printed fully the remaining values are filled by the values assigned  to fill value parameter 
from itertools import zip_longest
name= ['dada', 'mama', 'kaka', 'baba']
info= [9850,6032,3297]
for nm, inf in zip_longest (name, info):
    print (nm, inf)
#o.p:- dada 9850
mama 6032
kaka 3297
baba None

###########################################################
#use of fill value instead None
from itertools import zip_longest
name= ['dada', 'mama', 'kaka', 'baba']
info= [9850,6032,3297]
for nm, inf in zip_longest (name, info, fillvalue=0):
    print (nm, inf)
#o.p:- dada 9850
mama 6032
kaka 3297
baba 0

##########################################################
#use of all():- if all the values are true then it will produce output(means the not the null or 0 present)
lst=[2,3,6,8,9]
if all(lst):
    print('all values are true')
else:
    print('Useless')
#o..p:- all values are true

#########################
lst=[2,3,0,8,9]
if all(lst):
    print('all values are true')
else:
    print('Useless')
#o.p:- Useless

#################################
#use of any()
Something value are present in the list means all the value are not same value are null and come having some value 
lst=[0,0,0,8,0]
if any(lst):
    print('It has some value')
else:
    print('Useless')
#o.p:- It has some value

##########################################################
#use of any
lst=[0,0,0,0,0]
if any(lst):
    print('It has some value')
else:
    print('Useless')
#o.p:-Useless

#########################################################

#count() :- it is used I deep learing()
from itertools import count
counter=count()			
print(next(counter))			#0
print(next(counter))			#1
print(next(counter))			#2
#o.p:-0
1
2

##########################################################
#Now let us start from 1
from itertools import count
counter=count(start=1)
print(next(counter))
print(next(counter))
print(next(counter))
#o.p:-1
2
3

#############################################################
#cycle()
#suppose you have repeated tasks to be done, in the certain time then you can use this method
import itertools
instructions= ("Eat", "code", "sleep")
for instruction in itertools.cycle(instructions):
    print(instruction)
    #o.p:- Eat
Code
Sleep
Eat
Code
sleep
Eat
Code
sleep
Eat
Code
Sleep……………………………

#################################################################
#repeat():-It can repeat the task as you can give the task input
from itertools import repeat
for msg in repeat ("keep patience", times=3):
    print(msg)
#o.p:- keep patience
keep patience
keep patience
##############################################################
#group():-Group are the variable not a  special key world. It can group the listed element
from itertools import combinations
player={'john','jain','sumit'}
for group in combinations(player,2):
    print(group)
#o.p:- ('jain', 'sumit')
('jain', 'john')
('sumit', 'john')

############################################################
#group are the variable not the special key word
from itertools import combinations
player={'john','jain','sumit'}
for x in combinations(player,2):
    print(x)
#o.p:- ('jain', 'sumit')
('jain', 'john')
('sumit', 'john')

############################################################
#combinations()
from itertools import combinations
players=['John','Jani','Janardhan']
for i in combinations(players,2):
    print(i)
#o.p:- ('John', 'Jani')
('John', 'Janardhan')
('Jani', 'Janardhan')

#####################################################
from itertools import permutations
players=['John','Jani','Janardhan']
for seat in permutations(players,2):
    print(seat)
#o.p:-('John', 'Jani')
('John', 'Janardhan')
('Jani', 'John')
('Jani', 'Janardhan')
('Janardhan', 'John')
('Janardhan', 'Jani')

#######################################################
#product()
from itertools import product
team_a=['Rohit','Pandya','Bumrah']
team_b=['virat','Manish','Sami']
for pair in product(team_a,team_b):
    print(pair)
#o.p:-('Rohit', 'virat')
('Rohit', 'Manish')
('Rohit', 'Sami')
('Pandya', 'virat')
('Pandya', 'Manish')
('Pandya', 'Sami')
('Bumrah', 'virat')
('Bumrah', 'Manish')
('Bumrah', 'Sami')

##########################################################
age=[27,17,21,19]
adults=filter(
    lambda age:age>=18,
    age
     )
print([age for age in adults])
#o.p:- [27, 21, 19]

###########################################################
#shallow copy and deep copy
#Copy an Object in Python
#Copy using = operator
old_list = [[1, 2, 3], [4, 5, 6], [7, 8, 'a']]
new_list = old_list
new_list[2][2] = 9
print('Old List:', old_list)
print('ID of Old List:', id(old_list))
#2766531782016
print('New List:', new_list)
print('ID of New List:', id(new_list))
# same-2766531782016

#As you can see from the output both variables 
#old_list and new_list shares the same id i.e 140673303268168.

#################################################
#Essentially, sometimes you may want to have the original values unchanged and only modify the new values or vice versa.In Python, there are two ways to create copies:
# Shallow Copy
#Deep Copy
#We use the copy module of Python for  shallow and deep copy operations. 
#Suppose, you need to copy the compound list say x.

x=[1,2,3]
import copy
copy.copy(x)			#Here, the copy() return a shallow copy of x. 	
copy.deepcopy(x)		#Similarly, deepcopy() return a deep copy of x.
#A shallow copy creates a new object 
#which stores the reference of the original elements.
import copy
old_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
new_list = copy.copy(old_list)

print("Old list:", old_list)
print("New list:", new_list)
#This means it will create new and independent object with same content. 
#To verify this, we print the both old_list and new_list.
#To confirm that new_list is different from old_list
# we try to add new nested object to original and check it.
import copy
old_list = [[1, 1, 1], [2, 2, 2], [3, 3, 3]]
new_list = copy.copy(old_list)
old_list.append([4, 4, 4])
print("Old list:", old_list)
print("New list:", new_list)
#In the above program, we created a shallow copy of old_list. The new_list contains references to original nested objects stored in old_list. Then we add the new list i.e [4, 4, 4] into old_list. This new sublist was not copied in new_list.

##########################################################
#However, when you change any nested objects in old_list, the changes appear in new_list.
import copy
old_list = [[1, 1, 1], [2, 2, 2], [3, 3, 3]]
new_list = copy.copy(old_list)
old_list[1][1] = 'AA'
print("Old list:", old_list)
print("New list:", new_list)

#n the above program, we made changes to old_list i.e old_list[1][1] = 'AA'. 
#Both sublists of old_list and new_list at index [1][1] were modified. This is becauses, both lists share the reference of same nested objects.

############################################################
#Deep Copy
#A deep copy creates a new object and  recursively adds the copies of nested objects present in the original elements.
import copy
old_list = [[1, 1, 1], [2, 2, 2], [3, 3, 3]]
new_list = copy.deepcopy(old_list)
print("Old list:", old_list)
print("New list:", new_list)

#However, if you make changes to any nested objects in original object old_list,  you’ll see no changes to the copy new_list.

import copy
old_list = [[1, 1, 1], [2, 2, 2], [3, 3, 3]]
new_list = copy.deepcopy(old_list)
old_list[1][0] = 'BB'
print("Old list:", old_list)
print("New list:", new_list)
#In the above program, when we assign a new value to old_list, we can see only the old_list is modified. This means, both the old_list and the new_list are independent. 
import copy
lst1=[1,2,[3,4],5]		#using shallow copy
lst2=copy.copy(lst1)
print(f"The id of lst1 :{id(lst1)} and value is {lst1}and id of lst2:{id(lst2)} and the value is {lst2}")
"""
The id of lst1 :2335553487232 and value is [1, 2, [3, 4], 5]and id of lst2:2335553755904 and the value is [1, 2, [3, 4], 5]
"""
lst1=[1,2,[3,4],5]		#using shallow copy
lst3=copy.deepcopy(lst1)
print(f"The id of lst1 :{id(lst1)} and value is {lst1}and id of lst2:{id(lst3)} and the value is {lst3}")
"""
The id of lst1 :2335553487232 and value is [1, 2, [3, 4], 5]and id of lst2:2335552727424 and the value is [1, 2, [3, 4], 5]
"""
#####################################################
# importing "copy" for copy operations
import copy
 
# initializing list 1
li1 = [1, 2, [3,5], 4]

 ####################################################
# using deep copy to deep copy
li2 = copy.deepcopy(li1)

 ######################################################
# original elements of list
print ("The original elements before deep copying")
for i in range(0,len(li1)):
    print (li1[i],end=" ")	

 ####################################################
# adding and element to new list
li2[2][0] = 7

 ####################################################
# Change is reflected in l2
print ("The new list of elements after deep copying ")
for i in range(0,len( li1)):
    print (li2[i],end=" ")

 #####################################################
# Change is NOT reflected in original list as it is a deep copy
print ("The original elements after deep copying")
for i in range(0,len( li1)):
    print (li1[i],end=" ")
########################################
#Shallow copying on the contrary any change made in copied object same change is reflected in original object
# importing "copy" for copy operations
import copy
li1 = [1, 2, [3,5], 4]		# initializing list 1
li2 = copy.copy(li1)		# using copy to shallow copy 
# original elements of list
print ("The original elements before shallow copying")
for i in range(0,len(li1)):
    print (li1[i],end=" ")

 #####################################################
# adding and element to new list
li2[2][0] = 7
 
# checking if change is reflected
print ("The original elements after shallow copying")
for i in range(0,len( li1)):
    print (li1[i],end="")

    ####################################################
#unpacking of dictinary
friends={
    "Dale":9850,
    "male":6034
    }
contacts={
    "dada":8530,
    "mama":5286
    }
contacts.update(friends)
print(contacts)

####################################
#pipe operator
friends={"Satish":99021,
         "Ram":97603
         }
sham={"sham":85305}
all_friends=friends|sham
print(all_friends)

#############################
num=0
def change():
    num=1
change()
print(num)
#output will be 0
#In the same way we can not access outside of function  the value of variable declared inside the function
num=0
def change(x):
    x=1
change(x)
print(num)		#it will show an error

########################################
#use the admine user 
users=["admine","employee","manager","worker","staff"]
for user in users:
    if user=="admin":
        print("hello admin ,would you like to see the status report")
    elif user=="employee":
        print("hello employe")
    elif user=="manager":
        print("hello manager")
    elif user=="worker":
        print("hello worker")
    else:
        print("hello staff")

#####################################################
##  check the new user and old user
current_user=["ali","ahemd","fahad","aun","rana"]
new_users=["ali","rana","bilai","huzi","dula"]
for new_user in new_users:
    if new_user in current_user:
        print("person will need to enter  a new uersname")
        break
    else:
        print("saying that the username is avilable")
        break

##########################################################
#Hash code generation:- save the password in the form of hash code and check the user password and previous password are correct
import hashlib
hashlib.sha256("Gaurav@1234".encode('utf-8')).hexdigest()
'778d4ce2dfb7063981a67be5ba7955ba063c3319760bd3a0d2a85f5d15a594de'
len(hashlib.sha256("Gaurav@1234".encode('utf-8')).digest())
# 32 bit processor hashlib.sha256
############################################
import hashlib
hashlib.sha512("Gaurav@1234".encode('utf-8')).hexdigest()
'778d4ce2dfb7063981a67be5ba7955ba063c3319760bd3a0d2a85f5d15a594de'
len(hashlib.sha512("Gaurav@1234".encode('utf-8')).digest())

# 64 bit processor hashlib.sha512
********************Operation on csv file************************
For accesing the file first check the working Directory 
Access the file using the pandas 
Read the content of the file by using the absoulte path and store the data in the file 
#we can perform the operation on the csv file so it is nessaccery that the pandas  libreary are install first

import pandas as pd
f1=pd.read_csv('C:/Data Science/1-python/buzzers.csv')

######################################################
import os 
with open('buzzers.csv')as raw_data:
    print(raw_data.read())
# read () :- read is used to read the file content , it  can read the data as normal form

#####################################################    
#reading the CSV Data as lists
import csv 
with open('buzzers.csv')as raw_data:
    for line in csv.reader(raw_data):
        print(line)
#it can read the file data as in the list form
#[ ]:- data display in square bracket by line by line

####################################################
#reading the CSV data as Dictionaries
import csv 
with open('buzzers.csv')as raw_data:
    for line in csv.DictReader(raw_data):
        print(line)
#data display in the {} braces becauses of the we use the  dictionary in above and data are read line by lne

####################################################
#another apporach to read the csv data in the dictionaries by using the key value pair
import csv
with open('buzzers.csv') as data:
    flights={}
    for line in data:
        k,v=line.split(",")
        
        flights[k]=v
flights
#o.p:- it can show the only keys and value in the dictionary form . it having at last in keyword
###########################################################
#stripping then spliting the raw data i.e. /n
import csv
with open('buzzers.csv') as data:
    #
    flights={}
    for line in data:
        k,v=line.strip().split(",")
        flights[k]=v
flights
#o.p:- at the end of the line  each ‘/n’ are present  so that ‘/n’ are split or remove by using the split word

################################################
Decorator
#pre_recusittes of the decorator
def plus_one(number):
    number1=number+1
    return number1
plus_one(5)
#o.p:-6

##############################################
#definigh the function inside the another function
def plus_one(number):
    
    def add_one(number):
        number1= number+1
        return number1
    result=add_one(number)
    return result
plus_one(4)
#o.p:-5

#################################################
#passing the argument to the other function 
def plus_one(number):
    result1=number+1
    return result1
def function_call(function):
    result=function(5)
    return result

function_call(plus_one)
#o.p:-6

###############################################

#function retunring the another functions
def hello_function():
    def say_hii():
        return "hii"
    return say_hii
hello=hello_function() # when you function(say_hii) is returing the function (say_hii)
                        #then it is nessacary to assign the outer function(hello_function) to the variable(hello)
                        #And call the varible(hello())
hello()
#o.p:- hii

Note:- always remember when you call the  hello_function() directly then it will display the object not hi
. Therefore you need to assign it to hello first then call hello() function

###################################################
Pass the function as argument
Def add(x,y):
	Return x+y
Def calculate(func ,x,y):
	Return func(x,y)
Result =calculate(add,4,6)
Print(result)
#o..p:-10




**************************lambda function**************************
#Lambdaa function/Anonymous function:-
1.	Lambda function is a small anonymous function 
2.	A lambda  function can take any number of argument ,but can only have one expression
3.	The power of lambda is better show when you use them as an anonymous function is required for a small or short period of time
4.	Space complexity :- reduce because occupy the explicitly memory
Simple function:-
def add(a,b,c):
    sum=a+b+c
    return sum
print(add(4,5,6))			#o.p:-15
# lambda function
add=lambda a,b,c:a+b+c
add(4,5,6)				#o.p:-15

####################################################
# simple function 
def mult(a,b,c):
    mul=a*b*c
    return mul
print(mult(4,5,6))
# positional parametr:-by using the lambda fun
mult=lambda a,b,c: a*b*c
mult(4,5,6)
#o.p:-120

#################################################
#arbetary fun:- we can pass n number  of parameter
val=lambda *args:sum(args)
val(1,2,3,4,5,6)
#o.p:-21

##################################################
#* aargs normal fun
def myfun(*args):
    for i in args:
        print(i)					#o.p:- hello python how  are you
myfun("hello","python","how ","are","you")

#lambda
myfun=lambda *args:args
print("hello","python","how ","are","you")    
 #o.p:- hello python how  are you

##################################################
#simple program
def person(name,*data):
    print(name)
    print(data)
person("navin",28,"mumbai",12345678)
#o.p:- navin 28 mumbai 12345678
#lambda
person=lambda *data,name: data
print("navin",28,"mumbai",12345678)
#o.p:- navin 28 mumbai 12345678
"""

****sir ne quetion vichar la hota oral la *****
#taking the input from the user
x=int(input("enter the number:"))
def add():
    y=x+5
    print(y)
add()

# passsing the x as the postional arrugment
def add(x):
    y=x+5
    print(y)
add(10)

'''lambda with positional  aregument as x
x=int (input("enter the number:"))
add=lambda x:x+5
add(x)

#lambda without positional argument as x
x=int (input("enter the number:"))
add=lambda :x+5
add()

################################
#** passing the key word as the argument
def person(name,**data):
    print(name)
    print(data)
person(name="navin",age=28,place="mumbai",mob=12345678)
#o.p:- navin
{'age': 28, 'place': 'mumbai', 'mob': 12345678}


#lambda
person=lambda **data:data
person(name='navin',age=28,place="mumbai",mob=12345678)
#o.p:- navin
{'age': 28, 'place': 'mumbai', 'mob': 12345678}

###########################################################
#** dictionary like
def person(name,**data):
    print(name)
    for i,j in data.items():
        print(i,j)
person(name="navin",age=28,place="mumbai",mob=12345678)
#o.p:- ['navin', 28, 'mumbai', 12345678]

# lambda fun
person=lambda **data:[(j)for i,j in data.items()]
person(name='navin',age=28,place='mumbai',mob=12345678)
#o.p:- ['navin', 28, 'mumbai', 12345678]

##########################################################
#call the as direct value
val =lambda **data:sum(data.values())
val(a=1,b=2,c=3,d=5)
#o.p:- 11

#########################################################
#take the square of the list parameter lambda function in the list industry imp
lst1=[1,2,3,4,5,6,7]
sqr=lambda lst1:[i**2 for i in lst1]
print(sqr(lst1))
#output:-[1, 4, 9, 16, 25, 36, 49]

########################################################




Python for Data Science
#What is Pandas DataFrame?
#pandas DataFrame is a Two-Dimensional data structure, an immutable, heterogeneous tabular data structure with labeled axes rows, and columns.

#DataFrame Features
1)	DataFrames support named rows & columns.
2)	you can also provide names to rows.
3)	Supports heterogeneous collections of data.
4)	DataFrame labeled axes (rows and columns).
#Installing Pandas
1)	step-1 go to anaconda navigator
2)	step-2 select environment tab
3)	step-3 by default it will be base terminal
4)	step-4 on base terminal-pip install pandas
5)	Or conda install pandas

######################################
#Upgrade Pandas to Latest or Specific Version on base terminal write :-conda install --upgrade pandas

#upgrade to specific version:-conda update pandas==1.5.3
Note :- Do not install the spyder  on c Drive

********************operation on DataFrame*************************
#To check the version of pandas
import pandas as pd
pd.__version__
#o.p:- 1.5.3

#########################################################
# Create pandas DataFrame Create using Construct. Create pandas DataFrame from List
import pandas as pd
technologies = [ ["Spark",20000, "30days"], 
                 ["pandas",20000, "40days"], 
               ]
df=pd.DataFrame(technologies		) #D and F in the DataFrame are in the capital letter always
print(df)
#o.p:-       	 0     	 1    	   	2		#by default the row and column index are given
0 	  Spark  	20000  	30days
1  	 pandas  	20000 		 40days

####################################################
#check the size of the data frame
df.size 		#o.p:-6(it can give the number of element in the dataframe)
###################################################
Note1:-Since we have not given labels to columns and indexes, DataFrame by default assigns incremental sequence numbers as labels to both rows and columns, these are called Index.

###################################################
# Add Column & Row Labels to the DataFrame
column_names=["Courses","Fee","Duration"]
row_label=["a","b"]
df=pd.DataFrame(technologies,columns=column_names,index=row_label)
print(df)

#o.p:-  		Courses    	Fee 		Duration
a  	 	Spark  		20000   	30days
b 	 	pandas  	20000   	40days

####################################################
#Check the data type of the dataframe element 
df.dtypes 
#o.p:- Courses     object
Fee          int64
Duration    object
dtype: object

##################################################
#You can also assign custom data types to columns. set custom types to DataFrame
types={'Courses': str,'Fee':float,'Duration':str}
df.dtypes	#o.p:- the data type will be change

####################################################
# Create DataFrame from Dictionary
technologies = {
    'Courses':["Spark","PySpark","Hadoop"],
    'Fee' :[20000,25000,26000],
    'Duration':['30day','40days','35days'],
    'Discount':[1000,2300,1500]
              }
df = pd.DataFrame(technologies)
df
# Quick Examples of Converting Data Types in Pandas
# Convert all types to best possible data types
df2=df.convert_dtypes()
print(df2.dtypes)
#o.p:- 
Courses       string
Fee            Int64
Duration      string
Discount     Float64
dtype: object

#######################################################
# Change All Columns to Same data type
df = df.astype(str)
print(df.dtypes)
#o.p:- 
Courses      object
Fee          object
Duration     object
Discount     object
dtype: object

#######################################################
# Change data Type For One or Multiple Columns
df = df.astype({"Fee": int, "Discount": float})
print(df.dtypes)
#o.p:-
Courses       object
Fee            int32
Duration      object
Discount     float64
dtype: object

#####################################################
# Convert Data Type for All Columns in a List
df = pd.DataFrame(technologies)
df.dtypes
cols = ['Fee', 'Discount']
df[cols] = df[cols].astype('float')
df.dtypes
#o.p:- 
Courses       object
Fee          float64
Duration      object
Discount     float64
dtype: object

#####################################################
#Ignores error
df = df.astype({"Courses": int},errors='ignore')
df.dtypes
#o.p:- 
Courses       object
Fee          float64
Duration      object
Discount     float64
dtype: object

######################################################
# Generates error
df = df.astype({"Courses": int},errors='raise')
#o.p:- Error raise

#####################################################
# Converts feed column to numeric type
df = df.astype(str)
print(df.dtypes)
df['Discount'] = pd.to_numeric(df['Discount'])
df.dtypes
#o.p:- 
Courses      object
Fee          object
Duration     object
Discount     object
dtype: object
Out[18]: 
Courses       object
Fee           object
Duration      object
Discount     float64
dtype: object  

######################################################
#convert dataframe to csv
df.to_csv('data_file.csv')

#######################################################
# Create DataFrame from Dictionary
technologies = {
    'Courses':["Spark","PySpark","Hadoop"],
    'Fee' :[20000,25000,26000],
    'Duration':['30day','40days','35days'],
    'Discount':[1000,2300,1500]
              }
df = pd.DataFrame(technologies)
df

##################################################


#Create DataFrame From CSV File
df = pd.read_csv('data_file.csv')
#o.p:- The csv  file is created and the dataframe are stored in it 
#################################################
#Create DataFrame From CSV File
df = pd.read_csv('data_file.csv')
df
#o.p:- 
0 	 	Courses    	Fee 		Duration  		Discount
0           0    	Spark  		20000    	30day      		1000
1           1  	PySpark 	 25000   	40days     		 2300
2           2  	 Hadoop  	26000   	35days      		1500





*************************Pandas DataFrame – Basic Operations******************
# Create DataFrame with None/Null to work with examples
import pandas as pd
import numpy as np
technologies   = ({
    'Courses':["Spark","PySpark","Hadoop","Python","Pandas",None,"Spark","Python"],
    'Fee' :[22000,25000,23000,24000,np.nan,25000,25000,22000],
    'Duration':['30day','50days','55days','40days','60days','35day','','50days'],
    'Discount':[1000,2300,1000,1200,2500,1300,1400,1600]
          })
row_labels=['r0','r1','r2','r3','r4','r5','r6','r7']
df = pd.DataFrame(technologies, index=row_labels)
print(df)
#o.p:-
Courses       	Fee 		Duration  		Discount
r0    	Spark  		22000.0    	30day      		1000
r1  	PySpark  	25000.0   	50days     		 2300
r2   	Hadoop  	23000.0   	55days      		1000
r3  	 Python  	24000.0   	40days      		1200
r4   	Pandas      	NaN   		60days      		2500
r5     	None  		25000.	0    	35day      		1300
r6    	Spark  		25000.0           			1400
r7  	 Python  	22000.0   	50days      		1600

##################################################
#DataFrame properties
#shape of the dataframe
df.shape
#o.p:-(8, 4)

###############################################
#size of the dataframe
df.size
#o.p:-32

###################################################
#dataframe column and row information
df.columns		#o.p:- Index(['Courses', 'Fee', 'Duration', 'Discount'], dtype='object')
df.columns.values	#o.p:- array(['Courses', 'Fee', 'Duration', 'Discount'], dtype=object)
df.index			#o.p:-Index(['r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7'], dtype='object')
df.dtypes		#o.p:- Courses      object
Fee         float64
Duration     object
Discount      int64
dtype: object

#################################################
#Accessing one column contents
df['Fee']
#o.p:-
 0    20000
1    25000
2    26000
Name: Fee, dtype: int64

########################################################
##Accessing two columns contents
df[['Fee','Duration']]
#o.p:- it give the two column data value

#########################################################
#select certain rows and assign it to another dataframe
df2=df[6:]
df2
#o.p:- 
Empty DataFrame
Columns: [Unnamed: 0, Courses, Fee, Duration, Discount]
Index: []

######################################################
#accessing certain cell from column 'Duration'
df['Duration'][3]
#o.p:- '40days'

######################################################
#subtracting specific value from a column
df['Fee'] = df['Fee'] - 500
df['Fee']
#o.p:-
 r0    21500.0
r1    24500.0
r2    22500.0
r3    23500.0
r4        NaN
r5    24500.0
r6    24500.0
r7    21500.0
Name: Fee, dtype: float64

#######################################################
#Pandas to Manipulate DataFrame
#Describe DataFrame:- It will show 5 number summary 
# Describe DataFrame for all numberic columns
df.describe()
#o.p:- Fee     Discount
count      7.000000     8.000000
mean   23214.285714  1537.500000
std     1380.131119   570.557372
min    21500.000000  1000.000000
25%    22000.000000  1150.000000
50%    23500.000000  1350.000000
75%    24500.000000  1775.000000
max    24500.000000  2500.000000

####################################################
#rename() – Renames pandas DataFrame columns
df = pd.DataFrame(technologies, index=row_labels)
#o.p:-
Courses      	Fee		 Duration 	 Discount
r0    	Spark  		22000.0    	30day      	1000
r1  	PySpark  	25000.0   	50days      	2300
r2   	Hadoop  	23000.0   	55days     	1000
r3   	Python  	24000.0   	40days      	1200
r4   	Pandas      	NaN   		60days      	2500
r5     	None 		 25000.0    	35day      	1300
r6    	Spark  		25000.0               		1400
r7   	Python  	22000.0   	50days      	1600

####################################################
# Assign new header by setting new column names.
df.columns=['A','B','C','D']
df
#o.p:- 
A       	 	B      	 	C    		 D
r0    		Spark  		22000.0  	 30days	 1000
r1  		PySpark  	25000.0  	50days 	 2300
r2   		Hadoop  	23000.0  	55days  	1000
r3   		Python  	24000.0  	40days  	1200
r4   		Pandas     	 NaN  		60days  	2500
r5     		None  		25000.0   	35day  	1300
r6    		Spark 		 25000.0         			 1400
r7   		Python 	 22000.0  	50days  	1600

###########################################################
# Rename Column Names using rename() method
df = pd.DataFrame(technologies, index=row_labels)
df.columns=['A','B','C','D']
df2 = df.rename({'A': 'c1', 'B': 'c2'}, axis=1)
df2
#o.p:-		 c1      		 c2      		 C   		  D
r0    		Spark  		22000.0   	30days  	1000
r1  		PySpark 	 25000.0  	50days 	 2300
r2   		Hadoop  	23000.0  	55days  	1000
r3   		Python  	24000.0  	40days  	1200
r4   		Pandas      	NaN  		60days 	 2500
r5     		None  		25000.0   	35days		1300
r6    		Spark 		 25000.0          		1400
r7   		Python  	22000.0  	50days  	1600

#######################################
#renaming the column by using the axis keyword 
df2 = df.rename({'C': 'c3', 'D': 'c4'}, axis='columns')
df2
#o.p:- 
A       	 	B     		 c3   		 c4
r0    		Spark  		22000.0   	30day  	1000
r1  		PySpark  	25000.0  	50days  	2300
r2   		Hadoop  	23000.0  	55days  	1000
r3   		Python  	24000.0  	40days  	1200
r4   		Pandas      	NaN  		60days  	2500
r5     		None  		25000.0   	35day  	1300
r6    		Spark  		25000.0          			1400
r7   		Python  	22000.0  	50days  	1600

####################################################
df2 = df.rename(columns={'A': 'c1', 'B': 'c2'})
df2
#o.p:-
c1       		c2       		C     		D
r0    	Spark  		22000.0   	30day  	1000
r1  	PySpark  	25000.0  	50days  	2300
r2   	Hadoop  	23000.0  	55days  	1000
r3   	Python  	24000.0  	40days  	1200
r4   	Pandas      	NaN  		60days  	2500
r5     	None  		25000.0   	35day  	1300
r6   	 Spark  	25000.0          			1400
r7   	Python  	22000.0  	50days  	1600

####################################################
#Drop DataFrame Rows and Columns
df = pd.DataFrame(technologies, index=row_labels)

# Drop rows by labels
df1 = df.drop(['r1','r2'])
df1
#o.p:-   	Courses      	Fee 		Duration  	Discount
r0   		Spark  		22000.0    	30day      	1000
r3  		Python  	24000.0   	40days      	1200
r4  		Pandas      	NaN   		60days      	2500
r5    		None  		25000.0    	35day      	1300
r6  		 Spark  	25000.0               		1400
r7 		 Python  	22000.0   	50days      	1600

####################################################
# Delete Rows by position/index
df1=df.drop(df.index[1])
df1
#o.p:- Courses      	Fee 		Duration  		Discount
r0   Spark  		22000.0    	30day      		1000
r2  Hadoop  		23000.0   	55days      		1000
r3  Python  		24000.0   	40days      		1200
r4  Pandas      		NaN   		60days      		2500
r5    None  		25000.0    	35day      		1300
r6   Spark  		25000.0               			1400
r7  Python  		22000.0   	50days      		1600

######################################################
df1=df.drop(df.index[[1,3]])
df1
#o.p:- Courses      	Fee 		Duration  		Discount
r0   Spark  		22000.0    	30day      		1000
r2  Hadoop  		23000.0   	55days      		1000
r4  Pandas      		NaN   		60days      		2500
r5    None  		25000.0    	35day      		1300
r6   Spark  		25000.0               			1400
r7  Python  		22000.0   	50days      		1600

#####################################################
# Delete Rows by Index Range
df1=df.drop(df.index[2:])
df1
#o.p:- Courses      	Fee 		Duration  		Discount
r0    Spark  		22000.0   	 30day      		1000
r1  PySpark  		25000.0   	50days      		2300

#############################################
# When you have default indexs for rows
df = pd.DataFrame(technologies)
df1 = df.drop(0)
df1
#o.p:- Courses      		Fee 		Duration  		Discount
1  PySpark  			25000.0   	50days      		2300
2   Hadoop  			23000.0   	55days      		1000
3   Python  			24000.0   	40days      		1200
4   Pandas      			NaN   		60days      		2500
5     None  			25000.0    	35day      		1300
6    Spark  			25000.0               			1400
7   Python  			22000.0   	50days      		1600

####################################################
df = pd.DataFrame(technologies)
df1 = df.drop([0, 3])#it will delete row0 n row3
df1

#o.p:- Courses      		Fee 		Duration 	 	Discount
1  PySpark  			25000.0   	50days      		2300
2   Hadoop  			23000.0   	55days      		1000
4   Pandas      			NaN   		60days      		2500
5     None  			25000.0    	35day      		1300
6    Spark  			25000.0               			1400
7   Python  			22000.0   	50days      		1600

#########################################################
df1 = df.drop(range(0,2))#it will delete 0 and 1
df1
#o.p:- Courses     		Fee 		Duration  		Discount
2  Hadoop  			23000.0   	55days      		1000
3  Python  			24000.0   	40days      		1200
4  Pandas     			 NaN   		60days      		2500
5    None 			 25000.0    	35day      		1300
6   Spark  			25000.0               			1400
7  Python  			22000.0   	50days      		1600

##############################################################
import pandas as pd
technologies = ({
    'Courses':["Spark","PySpark","Hadoop","Python","pandas","Oracle","Java"],
    'Fee' :[20000,25000,26000,22000,24000,21000,22000],
    'Duration':['30day', '40days' ,'35days', '40days', '60days', '50days', '55days']
              })
df = pd.DataFrame(technologies)
print(df)
#get the dataframe in the row and column

####################################################
#Drop Column by Name
df2=df.drop(["Fee"], axis = 1)			# Drops 'Fee' column
print(df2)
#the fees column are drop from the dataframe

###################################################
# Explicitly using parameter name 'labels'
df2=df.drop(labels=["Fee"], axis = 1)
#it can drop the fees column

# Alternatively you can also use columns instead of labels.
df2=df.drop(columns=["Fee"], axis = 1)
#it can drop the fees column

###################################################
# Drop column by index.
print(df.drop(df.columns[1], axis = 1))
df = pd.DataFrame(technologies)

# using inplace=True
df.drop(df.columns[[2]], axis = 1, inplace=True)
print(df)

#############################################################
df = pd.DataFrame(technologies)
#Drop Two or More Columns By Label Name
df2=df.drop(["Courses", "Fee"], axis = 1)
print(df2)

##############################################################
#Drop Two or More Columns by Index
df = pd.DataFrame(technologies)
df2=df.drop(df.columns[[0,1]], axis = 1)
print(df2)

###########################################################
#Drop Columns from List of Columns
df = pd.DataFrame(technologies)
lisCol = ["Courses","Fee"]
df2=df.drop(lisCol, axis = 1)
print(df2)

############################################################
#Remove columns From DataFrame inplace
df.drop(df.columns[1], axis = 1, inplace=True)
df
# using inplace=True
############################################################
##Pandas Select Rows by Index (Position/Label)
import pandas as pd
import numpy as np
technologies   = ({
    'Courses':["Spark","PySpark","Hadoop","Python","Pandas",None,"Spark","Python"],
    'Fee' :[22000,25000,23000,24000,np.nan,25000,25000,22000],
    'Duration':['30day','50days','55days','40days','60days','35day','','50days'],
    'Discount':[1000,2300,1000,1200,2500,1300,1400,1600]
          })
row_labels=['r0','r1','r2','r3','r4','r5','r6','r7']
df = pd.DataFrame(technologies, index=row_labels)
print(df)

#imp for the interview
iloc[]:- for the index
Syntax
df.iloc[startrow:endrow, startcolumn:endcolumn]

loc[]:- for the label 

df = pd.DataFrame(technologies, index=row_labels)
# Below are quick example
df2=df.iloc[:, 0:2]
df2
#This line uses the slicing operator to get DataFrame items by index.
# The first slice [:] indicates to return all rows. 
#The second slice specifies that only columns between 0 and 2 (excluding 2) should be returned.

#############################################################
df2=df.iloc[0:2, :]
df2
#In this case, the first slice [0:2] is requesting only rows 0 through 1of the DataFrame.
#The second slice [:] indicates that all columns are required.

#############################################################
#Slicing Specific Rows and Columns using iloc attribute
df3=df.iloc[1:2, 1:3]
df3

#############################################################
#Another example
df3=df.iloc[:, 1:3]
df3
#The second operator [1:3] yields columns 1 and 3 only.
# Select Rows by Integer Index
#############################################################
#df2 = df.iloc[2]     # Select Row by Index
df2

############################################################
df2 = df.iloc[[2,3,6]]    # Select Rows by Index List and it can select the 2 ,3,6 row from the dataframe
df2 = df.iloc[1:5]   # Select Rows by Integer Index Range
df2 = df.iloc[:1]    # Select First Row
df2 = df.iloc[:3]    # Select First 3 Rows
df2 = df.iloc[-1:]   # Select Last Row
df2 = df.iloc[-3:]   # Select Last 3 Row
df2 = df.iloc[::2]   # Selects alternate rows

#############################################################
# Select Rows by Index Labels
df2 = df.loc['r2']          # Select Row by  Label
df2 = df.loc[['r2','r3','r6']]    # Select Rows by Index Label List
df2 = df.loc['r1':'r5']     # Select Rows by Label Index Range
df2 = df.loc['r1':'r5']     # Select Rows by Label Index Range
df2 = df.loc['r1':'r5':2]   # Select Alternate Rows with in Index La

##########################################################
import pandas as pd
import numpy as np
technologies = {
    'Courses':["Spark","PySpark","Hadoop","Python","pandas","Oracle","Java"],
    'Fee' :[20000,25000,26000,22000,24000,21000,22000],
    'Duration':['30days','40days','35days','40days',np.nan,None,'55days'],
    'Discount':[1000,2300,1500,1200,2500,2100,2000]
               }
index_labels=['r0','r1','r2','r3','r4','r5','r6']
df = pd.DataFrame(technologies,index=index_labels)
print(df)
#Select Rows by Index using Pandas iloc[]
#Select Row by Integer Index

print(df.iloc[2])
# Outputs
Courses     Hadoop
Fee          26000
Duration    35days
Discount      1500
Name: r3, dtype: object

####################################################

#Get Multiple Rows by Index List
# Select Rows by Index List
print(df.iloc[[2,3,6]])
# Outputs
  Courses    	Fee 		Duration  	Discount
r2  Hadoop  	26000  	 35days      	1500
r3  Python  	22000   	40days      	1200
r6    Java  	22000   	55days   	2000

#####################################################
#Get DataFrame Rows by Index Range
# Select Rows by Integer Index Range
print(df.iloc[1:5])
# Output
Courses   	 Fee	 Duration  	Discount
r1  PySpark  		25000   40days      2300
r2   Hadoop  		26000   35days      1500
r3   Python  		22000   40days      1200
r4   pandas  		24000      NaN      2500

################################################
# Select First Row by Index
print(df.iloc[:1])
# Outputs
   Courses    	Fee 	Duration 	 Discount
r0   Spark  	20000   30days      	1000

#################################################
# Select First 3 Rows
print(df.iloc[:3])
# Outputs
    Courses    		Fee 		Duration  		Discount
r0    Spark  		20000   	30days      		1000
r1  PySpark  		25000   	40days      		2300
r2   Hadoop  		26000   	35days      		1500

###################################################
# Select Last Row by Index
print(df.iloc[-1:])
# Outputs
 	Courses    	Fee 	Duration  	Discount
r6    	Java  		22000   55days      2000

#######################################################
# Select Last 3 Row
print(df.iloc[-3:])
# Outputs
   Courses    	Fee 	Duration  	Discount
r4  pandas  	24000      NaN      2500
r5  Oracle  	21000     None      2100
r6    Java  	22000   55days      2000

####################################################
# Selects alternate rows
print(df.iloc[::2])
# Output
   Courses    	Fee 	Duration  	Discount
r0   Spark  	20000   30days      1000
r2  Hadoop  	26000   35days      1500
r4  pandas  	24000      NaN      2500
r6    Java  	22000   55days  

####################################################
#summary of all the code
# Select Rows by Integer Index Range
print(df.iloc[1:5])
# Output
   Courses    	Fee 	Duration  	Discount
r1  PySpark  	25000   40days      2300
r2   Hadoop  	26000   35days      1500
r3   Python 	 22000   40days      1200
r4   pandas  	24000      NaN      2500
######################################################

# Select First Row by Index
print(df.iloc[:1])
# Outputs
   Courses    Fee 	Duration	  Discount
r0   Spark  	20000   30days      1000

#######################################################
# Select First 3 Rows
print(df.iloc[:3])
# Outputs
    Courses    		Fee 	Duration  	Discount
r0    Spark  		20000   30days      1000
r1  PySpark  		25000   40days      2300
r2   Hadoop  		26000   35days      1500

#######################################################
# Select Last Row by Index
print(df.iloc[-1:])
# Outputs
Courses    	Fee 	Duration  	Discount
r6    Java  	22000   55days      2000

#####################################################
# Select Last 3 Row
print(df.iloc[-3:])
# Outputs
  Courses    		Fee 	Duration  	Discount
r4  pandas  		24000      NaN      2500
r5  Oracle  		21000     None      2100
r6    Java  		22000   55days      2000

#########################################################
# Selects alternate rows
print(df.iloc[::2])
# Output
   Courses    	Fee 	Duration  	Discount
r0   Spark  	20000   30days      1000
r2  Hadoop  	26000   35days      1500
r4  pandas  	  24000      NaN      2500
r6    Java 	 22000   55days      2000

loc[]
# Using loc[] to take column slices
#loc[] syntax to slice columns  :-df.loc[:,start:stop:step]
## Selecte multiple columns

#Select Rows by Index Labels using Pandas loc[]
#Get Row by Label
# Select Row by Index Label
print(df.loc['r2'])
# Outputs
Courses     Hadoop
Fee          26000
Duration    35days
Discount      1500
Name: r2, dtype: object

##################################################
#Get Multiple Rows by Label List
# Select multiple Rows by Index Label List
print(df.loc[['r2','r3','r6']])
# Outputs
    Courses    	Fee 	Duration  	Discount
r2  PySpark  	25000   40days      2300
r3   Hadoop  	26000   35days      1500
r6   Oracle  	21000     None      2100

###################################################
#Get Rows Between Two Labels
# Select Rows by Label Index Range
print(df.loc['r1':'r5'])
# Outputs
Courses    	Fee 	Duration 	 Discount
r1  PySpark 	 25000   40days      2300
r2   Hadoop  	26000   35days      1500
r3   Python  	22000   40days      1200
r4   pandas  	24000      NaN      2500
r5   Oracle  	21000     None      2100

##############################################
# Select Alternate Rows with in Index Labels
print(df.loc['r1':'r5':2])
# Outputs
Courses    	Fee 	Duration  	Discount
r1  PySpark  	25000   40days      2300
r3   Python  	22000   40days      1200
r5   Oracle  	21000     None      2100

#####################################################
#Pandas Select Columns by Name or Index
# By using df[] Notation
df2=df['Courses']
## select multile columns
df2 = df[["Courses","Fee","Duration"]] 

###################################################
# Using loc[] to take column slices
#loc[] syntax to slice columns
#df.loc[:,start:stop:step]
## Selecte multiple columns
df2 = df.loc[:, ["Courses","Fee","Duration"]]
# Select Random columns 
df2 = df.loc[:, ["Courses","Fee","Discount"]]
# Select columns between two columns 
df2 = df.loc[:,'Fee':'Discount'] 
## Select columns by range
df2 = df.loc[:,'Duration':] 
# Select columns by range 
#All the columns upto 'Duration'
df2 = df.loc[:,:'Duration']  
## Select every alternate column
df2 = df.loc[:,::2]          

#########################################################
#Pandas iloc[] to Select Column by Index or Position
#Select Multiple Columns by Index Position
# Selected by column position
df2 = df.iloc[:,[1,2,3]]
df2
Fee 	Duration  	Discount
r0  	20000   30days      1000
r1  	25000   40days      2300
r2  	26000   35days      1500
r3  	22000   40days      1200
r4  	24000      NaN      2500
r5  	21000     None      2100
r6  	22000   55days      2000

######################################################
# Select between indexes 1 and 4 (2,3,4)
df2 = df.iloc[:,1:4]
df2
#Returns
     Fee 	Duration  	Discount
0  20000   30days      1000
1  25000   40days      2300

####################################################
# Select From 3rd to end
df2 = df.iloc[:,2:]
df2
#Returns
  Duration  Discount   Tutor
0   30days      1000  Michel
1   40days      2300     Sam

########################
 #Select First Two Columns
df2 = df.iloc[:,:2]
df2
#Returns
   Courses    Fee
0    Spark  20000
1  PySpark  25000

########################################################
#Pandas.DataFrame.query() by Examples
# Query all rows with Courses equals 'Spark'
df2=df.query("Courses == 'Spark'")
print(df2)

######################################################
# not equals condition
df2=df.query("Courses != 'Spark'")
df2

#####################################################
#Pandas Add Column to DataFrame
import pandas as pd
import numpy as np

technologies= {
    'Courses':["Spark","PySpark","Hadoop","Python","Pandas"],
    'Fee' :[22000,25000,23000,24000,26000],
    'Discount':[1000,2300,1000,1200,2500]
          }

df = pd.DataFrame(technologies)
print(df)

########################################################
#Pandas Add Column to DataFrame
# Add new column to the DataFrame
tutors = ['Ram', 'sham', 'Ghansham', 'Ganesh', 'Ramesh']
df2 = df.assign(TutorsAssigned=tutors)
print(df2)

####################################################
# Add multiple columns to the DataFrame
MNCCompanies = ['TATA','HCL','Infosys','Google','Amazon']
df2 = df.assign(MNCComp = MNCCompanies,TutorsAssigned=tutors )
df2

#################################################
# Derive New Column from Existing Column
df = pd.DataFrame(technologies)
df2 = df.assign(Discount_Percent=lambda x: x.Fee * x.Discount / 100)
print(df2)

################################################


#Append Column to Existing Pandas DataFrame
# Add New column to the existing DataFrame
df = pd.DataFrame(technologies)
df["MNCCompanies"] = MNCCompanies
print(df)

################################################
# Add new column at the specific position
df = pd.DataFrame(technologies)
df.insert(0,'Tutors', tutors )
print(df)

#############################################
#Pandas Rename Column with Examples
import pandas as pd
technologies = ({
  'Courses':["Spark","PySpark","Hadoop","Python","pandas","Oracle","Java"],
  'Fee' :[20000,25000,26000,22000,24000,21000,22000],
  'Duration':['30day', '40days' ,'35days', '40days', '60days', '50days', '55days']
              })
df = pd.DataFrame(technologies)
print(df.columns)

###########################################
#Pandas Rename Column Name Rename a Single Column 
df2=df.rename(columns = {'Courses':'Courses_List'})
print(df2.columns)

############################################
#Alternatively, you can also write the above statement by using axis=1 or axis='columns' Alternatively you can write above using axis, 
df2=df.rename({'Courses':'Courses_List'}, axis=1)
df2=df.rename({'Courses':'Courses_List'}, axis='columns')

################################################
#In order to change columns on the existing DataFrame without copying to the new DataFrame, you have to use inplace=True. Replace existing DataFrame (inplace). This returns None.
df.rename({'Courses':'Courses_List'}, axis='columns', inplace=True)
print(df.columns)

################################################
#Rename Multiple Columns
df.rename(columns = {'Courses':'Courses_List','Fee':'Courses_Fee', 
   'Duration':'Courses_Duration'}, inplace = True)
print(df.columns)
df.columns
##############################################
#Rename Columns with a List
column_names = ['Courses','Fee','Duration']
df.columns = column_names
print(df.columns)

#############################################
#Rename multiple columns with inplace
df.rename(columns = {'Courses':'Courses_List','Fee':'Courses_Fee', 
   'Duration':'Courses_Duration'}, inplace = True)
print(df.columns)

#################################################
#Quick Examples of Get the Number of Rows in DataFrame
rows_count = len(df.index)
rows_count
rows_count = len(df.axes[0])
rows_count

##############################################
df = pd.DataFrame(technologies)
row_count = df.shape[0		  # Returns number of rows
col_count = df.shape[1] 		 # Returns number of columns
print(row_count)
#Outputs - 4

#######################################
#Pandas Drop Rows From DataFrame
import pandas as pd
import numpy as np

technologies = {
    'Courses':["Spark","PySpark","Hadoop","Python"],
    'Fee' :[20000,25000,26000,22000],
    'Duration':['30day','40days',np.nan, None],
    'Discount':[1000,2300,1500,1200]
               }

indexes=['r1','r2','r3','r4']
df = pd.DataFrame(technologies,index=indexes)
print(df)

########################################################



#pandas Drop Rows From DataFrame Examples
# Drop rows by Index Label
df = pd.DataFrame(technologies,index=indexes)
df1 = df.drop(['r1','r2'])
print(df1)

######################################################
# Delete Rows by Index Labels
df1 = df.drop(index=['r1','r2'])
df1

######################################################
# Delete Rows by Index Labels & axis
df1 = df.drop(labels=['r1','r2'])
df1 = df.drop(labels=['r1','r2'],axis=0)

########################################################
# Delete Rows by Index numbers
df = pd.DataFrame(technologies,index=indexes)
df1=df.drop(df.index[[1,3]])
print(df1)

#####################################################
# Delete Rows by Index Range
df = pd.DataFrame(technologies,index=indexes)
df1=df.drop(df.index[2:])
print(df1)

####################################################
#Delete Rows when you have Default Indexes
# Remove rows when you have default index.
df = pd.DataFrame(technologies)
df1 = df.drop(0)
df3 = df.drop([0, 3])
df4 = df.drop(range(0,2))

################################################
#Remove DataFrame Rows inplace
# Delete Rows inplace
df = pd.DataFrame(technologies,index=indexes)
df.drop(['r1','r2'],inplace=True)
print(df)

#################################################


#Drop Rows that has NaN/None/Null Values
# Delete rows with Nan, None & Null Values
df = pd.DataFrame(technologies,index=indexes)
df2=df.dropna()
print(df2)

###############################################
#Remove Rows by Slicing DataFrame
df2=df[4:]     # Returns rows from 4th row
df2=df[1:-1]   # Removes first and last row
df2=df[2:4]    # Return rows between 2 and 4

##############################################
#Change All Columns to Same type in Pandas
#df.astype(str) converts all columns of Pandas DataFrame to string type.

df = df.astype(str)
print(df.dtypes)

##############################################
#Change Type For One or Multiple Columns in Pandas
# Change Type For One or Multiple Columns
df = df.astype({"Fee": int, "Discount": float})
print(df.dtypes)

#########################################
#Convert Data Type for All Columns in a List 
df = pd.DataFrame(technologies)
cols = ['Fee', 'Discount']
df[cols] = df[cols].astype('float')

##################################################
# By using a loop
for col in ['Fee', 'Discount']:
    df[col] = df[col].astype('float')

###################################################
#Raise or Ignore Error when Convert Column type Fails
df = df.astype({"Courses": int},errors='ignore')
# Generates error
df = df.astype({"Courses": int},errors='raise')

##################################################
#Using DataFrame.to_numeric() to Convert Numeric Types
# Converts feed column to numeric type
df['Fee'] = pd.to_numeric(df['Fee'])
###############################################
#Convert multiple Numeric Types using apply() Method
# Convert Fee and Discount to numeric types
df = pd.DataFrame(technologies)
df[['Fee', 'Discount']] =df [['Fee', 'Discount']].apply(pd.to_numeric)
print(df.dtypes)

##############################################
#Quick Examples of Get the Number of Rows in DataFrame
rows_count = len(df.index)
rows_count
rows_count = len(df.axes[0])
rows_count

###############################################
df = pd.DataFrame(technologies)
row_count = df.shape[0]  # Returns number of rows
col_count = df.shape[1]  # Returns number of columns
print(row_count)
#Outputs - 4

###############################################
#pandas Apply Function to a Column
# Below are quick examples
# Using Dataframe.apply() to apply function add column
import pandas as pd
import numpy as np
data = [(3,5,7), (2,4,6),(5,8,9)]
df = pd.DataFrame(data, columns = ['A','B','C'])
print(df)
def add_3(x):
   return x+3
df2 = df.apply(add_3)
df2

############################################################
# Using apply function single column
def add_4(x):
   return x+4
df["B"] = df["B"].apply(add_4)
df["B"]
#########################################################
# Apply to multiple columns
df[['A','B']] = df[['A','B']].apply(add_3)
df
########################################################
# apply a lambda function to each column
df2 = df.apply(lambda x : x + 10)

########################################################
# apply() function on selected list of multiple columns
df = pd.DataFrame(data, columns = ['A','B','C'])
df[['A','B']] = df[['A','B']].apply(add_3)
print(df)

#######################################################
#Apply Lambda Function to Each Column
df2 = df.apply(lambda x : x + 10)
print(df2)

########################################################
#Apply Lambda Function to Single Column Using Dataframe.apply() and lambda function
df["A"] = df["A"].apply(lambda x: x-2)
print(df)

###########################################################
#Using pandas.DataFrame.transform() to Apply Function Column Using DataFrame.transform() 
def add_2(x):
    return x+2
df = df.transform(add_2)
print(df)

#########################################################
#Using pandas.DataFrame.map() to Single Column
df['A'] = df['A'].map(lambda A: A/2.)
print(df)

#########################################################
#Using Numpy function on single Column Using Dataframe.apply() & [] operator
df['A'] = df['A'].apply(np.square)
print(df)

##########################################################
#Using NumPy.square() Method Using numpy.square() and [] operator
df['A'] = np.square(df['A'])
print(df)

#############################################################


#Pandas groupby()  
groupby is used for grouping the data according to the categories and applying a function to the categories. It also helps to aggregate data efficiently. The Pandas groupby() is a very powerful function with a lot of variations. It makes the task of splitting the Dataframe over some criteria really easy and efficient.
 Pandas dataframe.groupby() function is used to split the data into groups based on some criteria
With Examples 

import pandas as pd
technologies   = ({
    'Courses':["Spark","PySpark","Hadoop","Python","Pandas","Hadoop","Spark","Python","NA"],
    'Fee' :[22000,25000,23000,24000,26000,25000,25000,22000,1500],
    'Duration':['30days','50days','55days','40days','60days','35days','30days','50days','40days'],
    'Discount':[1000,2300,1000,1200,2500,None,1400,1600,0]
          })
df = pd.DataFrame(technologies)
print(df)
'''o.p:- Courses    Fee Duration  Discount
0    Spark  22000   30days    1000.0
1  PySpark  25000   50days    2300.0
2   Hadoop  23000   55days    1000.0
3   Python  24000   40days    1200.0
4   Pandas  26000   60days    2500.0
5   Hadoop  25000   35days       NaN
6    Spark  25000   30days    1400.0
7   Python  22000   50days    1600.0
8       NA   1500   40days       0.0'''

##################################################
# Use groupby() to compute the sum
df2 =df.groupby(['Courses']).sum()
print(df2)
 '''o.p:-    
Courses                  Fee  Discount     
Hadoop   	48000    1000.0
NA        	1500       0.0
Pandas   	26000    2500.0
PySpark  	25000    2300.0
Python   	46000    2800.0
Spark    	47000    2400.0'''

######################################################


# Group by multiple columns
df2 =df.groupby(['Courses', 'Duration']).sum()
print(df2)
'''o.p:-                   
Courses	 Duration      Fee  Discount           
Hadoop  	35days    25000       0.0
       		 55days    23000    1000.0
NA  		    40days     1500       0.0
Pandas  	60days    26000    2500.0
PySpark 	50days    25000    2300.0
Python  	40days    24000    1200.0
        		50days    22000    1600.0
Spark   	30days    47000    2400.0'''

#####################################################
#Add Index to the grouped data
# Add Row Index to the group by result
df2 = df.groupby(['Courses','Duration']).sum().reset_index()
print(df2)
'''o.p:-
Courses 	Duration    Fee 	 Discount
0   Hadoop   		35days  25000       0.0
1   Hadoop   		55days  23000    1000.0
2       NA   		40days   1500       0.0
3   Pandas   		60days  26000    2500.0
4  PySpark   		50days  25000    2300.0
5   Python   		40days  24000    1200.0
6   Python   		50days  22000    1600.0
7    Spark   		30days  47000    2400.0'''

######################################################
# Group by on multiple columns
df2 =df.groupby(['Courses', 'Duration']).sum()
print(df2)
'''o.p:-                
Courses 	Duration	Fee  Discount         
Hadoop  	35days    25000       0.0
        		55days    23000    1000.0
NA      		40days     1500       0.0
Pandas  	60days    26000    2500.0
PySpark 	50days    25000    2300.0
Python  	40days    24000    1200.0
        		50days    22000    1600.0
Spark   	30days    47000    2400.0'''

#######################################################
#Pandas Get Column Names from DataFrame
import pandas as pd
import numpy as np

technologies= {
    'Courses':["Spark","PySpark","Hadoop","Python","Pandas"],
    'Fee' :[22000,25000,23000,24000,26000],
    'Duration':['30days','50days','30days', None,np.nan],
    'Discount':[1000,2300,1000,1200,2500]
          }
df = pd.DataFrame(technologies)
print(df)
'''o.p:-  Courses    Fee Duration  Discount
0    Spark  22000   30days      1000
1  PySpark  25000   50days      2300
2   Hadoop  23000   30days      1000
3   Python  24000     None      1200
4   Pandas  26000      NaN      2500'''

########################################################
# Get the list of all column names from headers
column_headers = list(df.columns.values)
print("The Column Header :", column_headers)
#o.p:-The Column Header : ['Courses', 'Fee', 'Duration', 'Discount']

#########################################################
#Using list(df) to get the column headers as a list
column_headers = list(df.columns)
column_headers          #o.p:-['Courses', 'Fee', 'Duration', 'Discount']
#Using list(df) to get the list of all Column Names
column_headers = list(df)
column_headers
#o.p:-Out[59]: ['Courses', 'Fee', 'Duration', 'Discount']







******************shuffle**********************
#Pandas Shuffle DataFrame Rows 
import pandas as pd
technologies = {
    'Courses':["Spark","PySpark","Hadoop","Python","pandas","Oracle","Java"],
    'Fee' :[20000,25000,26000,22000,24000,21000,22000],
    'Duration':['30day','40days','35days','40days','60days','50days','55days'],
    'Discount':[1000,2300,1500,1200,2500,2100,2000]
               }
df = pd.DataFrame(technologies)
print(df)
#Pandas Shuffle DataFrame Rows shuffle the DataFrame rows & return all rows
df1 = df.sample(frac = 1)
print(df1)
#frac=1 it can do the shuffling of the data 

##############################################################
# Create a new Index starting from zero:- creating the new index starting from zero and it give the  older inde aswell  as  the newer index ie.shuffle index
df1 = df.sample(frac = 1).reset_index()
print(df1)

#############################################################
# Drop shuffle Index :- it can drop the shuffling the index value
df1 = df.sample(frac = 1).reset_index(drop=True)
print(df1)

###############################################################
import pandas as pd
technologies = {
    'Courses':["Spark","PySpark","Python","pandas"],
    'Fee' :[20000,25000,22000,30000],
    'Duration':['30days','40days','35days','50days'],
              }
index_labels=['r1','r2','r3','r4']
df1 = pd.DataFrame(technologies,index=index_labels)

technologies2 = {
    'Courses':["Spark","Java","Python","Go"],
    'Discount':[2000,2300,1200,2000]
              }
index_labels2=['r1','r6','r3','r5']
df2 = pd.DataFrame(technologies2,index=index_labels2)


************************join***************************
1. it is important in ML
2.The various tables are join in the csv file 
4. database datapipeline .csv understand the data(EDA)Process modelEvalution model(also called RISP_ML(Q))
5. join for join the only one column is need to indentical
6. Pre requiste to the join there us comman column in the all the table or given table
7. There are various type of the join are present i.e. INNER ,LEFT , Right , Full 
INNER JOIN:-
1. Only common rows will display
2. in this table we can see that India and Nepal are comman entry
3. the join is made on country id of the both the tables
4.show the data only for matching records 
5. pandas inner join is mostly used join, It is used to join two DataFrames on indexes.When indexes don’t match the rows get dropped from both DataFrames.
LEFT Join 
1. In the left join all the data of left table will be display and only matching records /rows of right table will be display
Right join
1. all the records of right table will be display but only matching records of the left table will display
OUTER join
1. in the outer join all the records of left table and all the records af right table are display irrespective to it matching or not
Note :- By default the python will do the  left join.

Syntax:- variable name =DataFrame .join(Tablename1,tablename2,lsuffix =”_left”,rsuffix=”_right” ,how =”join name”)
	While joining the data frame is not mention column name on which column has to be done the join pandas inner join is mostly us ejon 
	It is used to join two dataframe on indexes
	If there is no explicity mentioning of the column
	Merge() = inner join by default left join not mention
	To_csv make the csv file
	Read_csv read the data of the csv file
serial of the right and left suffix will be change it can not harm on the dataframe
#lsuffix and rsuffix is important in the join
#'how=' it can show that which operation i.e. which join we want to perform on the dataframe
#syntax:-
#variblename=table1/dataframe1.join(table2/dataframe2 ,lsuffix="_left",rsuffix="_right",how=' name of join which join you want to perform on the dataframe')
#we can change the sequiece of the lsuffix and rsuffix
#from "how" statement we can specifies the which join is we can use in the excution
##################################################
# pandas join ,by default it will join the table left join
df3=df1.join(df2, lsuffix="_left", rsuffix="_right")
print(df3)
# In the left join all the data of left table will be display and only matching records /rows of right table will be display

########################################################
# pandas Inner join DataFrames
df3=df1.join(df2, lsuffix="_left", rsuffix="_right", how='inner')
print(df3)
#. Only common rows will display
"Out[26]: 
   courses_left  	discount	 courses_right   fee 	duration
r1        spark      	2134         spark  		2134   34days
r3      python       	4567       python   		4567   43days"""

############################################################
 #pandas Left join DataFrames
df3=df1.join(df2, lsuffix="_left", rsuffix="_right", how='left')
print(df3)
# In the left join all the data of left table will be display and only matching records /rows of right table will be display
"""Out[28]: 
   courses_left   	fee duration courses_right  discount
r1        spark  		2134   34days         spark    2134.0
r2      pyspark  	3456   54days           NaN       NaN
r3      python   	4567   43days       python     4567.0
r4       pandas   	768   36days           NaN       NaN"""

################################################################
 #pandas Right join DataFrames
df3=df1.join(df2, lsuffix="_left", rsuffix="_right", how='right')
print(df3)
#. all the records of right table will be display but only matching records of the left table will display
"""df3
Out[30]: 
   courses_left     	fee duration courses_right  discount
r1        spark  		2134.0   34days         spark      2134
r6          NaN    	 NaN      NaN          java      3456
r3      python   	4567.0   43days       python       4567
r5          NaN     	NaN      NaN            go       565"""

###############################################################
# pandas join on columns
df3=df1.set_index('Courses').join(df2.set_index('Courses'), how='inner')
print(df3)
##############################################################
# pandas join on columns
df3=df1.set_index('Courses').join(df2.set_index('Courses'), how='left')
print(df3)

########################################################
# pandas join on columns
df3=df1.set_index('Courses').join(df2.set_index('Courses'), how='right')
print(df3)

#########################################################
#we can join(use any join i.e. left ,right or inner) the more than one column by using the doble coat and [] bracket
df3=df1.set_index(["courses","discount"]).join(df2.set_index(["courses","discount"]),how='right')
df3

###########################################################
#inner join=Pandas Merge DataFrames
import pandas as pd
technologies = {
    'Courses':["Spark","PySpark","Python","pandas"],
    'Fee' :[20000,25000,22000,30000],
    'Duration':['30days','40days','35days','50days'],
              }
index_labels=['r1','r2','r3','r4']
df1 = pd.DataFrame(technologies,index=index_labels)

technologies2 = {
    'Courses':["Spark","Java","Python","Go"],
    'Discount':[2000,2300,1200,2000]
              }
index_labels2=['r1','r6','r3','r5']
df2 = pd.DataFrame(technologies2,index=index_labels2)

# Using pandas.merge()
df3= pd.merge(df1,df2)

# Using DataFrame.merge()
df3=df1.merge(df2)

########################################################
#Use pandas.concat() to Concat Two DataFrames
import pandas as pd
df = pd.DataFrame({'Courses': ["Spark","PySpark","Python","pandas"],
                    'Fee' : [20000,25000,22000,24000]})

df1 = pd.DataFrame({'Courses': ["Pandas","Hadoop","Hyperion","Java"],
                    'Fee': [25000,25200,24500,24900]})

# Using pandas.concat() to concat two DataFrames
data = [df, df1]
df2 = pd.concat(data)
df2

###########################################################
#Concatenate Multiple DataFrames Using pandas.concat()
import pandas as pd
df = pd.DataFrame({'Courses': ["Spark", "PySpark", "Python", "Pandas"],
                    'Fee' : ['20000', '25000', '22000', '24000']}) 
  
df1 = pd.DataFrame({'Courses': ["Unix", "Hadoop", "Hyperion", "Java"],
                    'Fee': ['25000', '25200', '24500', '24900']})
  
df2 = pd.DataFrame({'Duration':['30day','40days','35days','60days','55days'],
                    'Discount':[1000,2300,2500,2000,3000]})
  
# Appending multiple DataFrame
df3 = pd.concat([df, df1, df2])
print(df3)

##########################################################
#Use pandas.concat() to Concat Two DataFrames
import pandas as pd
df = pd.DataFrame({'Courses': ["Spark","PySpark","Python","pandas"],
                    'Fee' : [20000,25000,22000,24000]})

df1 = pd.DataFrame({'Courses': ["Pandas","Hadoop","Hyperion","Java"],
                    'Fee': [25000,25200,24500,24900]})

# Using pandas.concat() to concat two DataFrames
data = [df, df1]
df2 = pd.concat(data)
df2

###########################################################
#Concatenate Multiple DataFrames Using pandas.concat()
import pandas as pd
df = pd.DataFrame({'Courses': ["Spark", "PySpark", "Python", "Pandas"],
                    'Fee' : ['20000', '25000', '22000', '24000']}) 
  
df1 = pd.DataFrame({'Courses': ["Unix", "Hadoop", "Hyperion", "Java"],
                    'Fee': ['25000', '25200', '24500', '24900']})
  
df2 = pd.DataFrame({'Duration':['30day','40days','35days','60days','55days'],
                    'Discount':[1000,2300,2500,2000,3000]})
  
# Appending multiple DataFrame
df3 = pd.concat([df, df1, df2])
print(df3)

#########################################################
# Write DataFrame to CSV File with Default params.
df3.to_csv("c:/10-python/courses.csv")
#read CSV
# Import pandas
import pandas as pd

# Read CSV file into DataFrame
df = pd.read_csv('courses.csv')
print(df)

############################################################
# Write DataFrame to Excel file
df.to_excel('c:/10-python/Courses.xlsx')

########################################################
import pandas as pd
# Read Excel file
df = pd.read_excel('c:/10-python/Courses.xlsx')
print(df)

#####################################################
# Using Series.values.tolist()
col_list = df.Courses.values.tolist()
print(col_list)

####################################################
# Using Series.values.tolist()
col_list = df["Courses"].values.tolist()
print(col_list)

###################################################
# Using list() Function
col_list =  list(df["Courses"])
print(col_list)

####################################################

# Conver to numpy array
col_list = df['Courses'].to_numpy()
print(col_list)

#####################################################
# Get by Column Index
col_list = df[df.columns[0]].values.tolist()
print(col_list)

########################################################
# Convert Index Column to List
index_list = df.index.tolist()
print(index_list)

##########################################################



pandas series
Series
	Module pandas series
	Work on column use series
	Work on dataframe use dataframe
	It has no column name and it dose not have index it hash exclibility index value
	A series  is used to module one-dimension data(column)
	It is similar to the list In python but not a list
	The series object also has a few more bits of data including an index and rows it has no built in index but it has exclisitive index are available
	NULL value then drop or replace 
	Rows increases  model have the higher performance
	Rows decreases model have low performance
	NAN is dangerous
	NAN value stands for not a null number and is usually ignored in arithematic
	Operation are similar to NULL in sql
	If you load data from csv file an apply the value otherwise that value  you can replace otherwise drop that value
	Series has duplicate value
	The series data structure provides the support for basic CRUD operation  create, read, update, delete
	A series  is used to model one dimensional data similar to a list in python the series object also has a few more bits of the data including an #index and name

import pandas as pd
songs2=pd.Series([334,355,54,76],name='counts')
songs2
#it is esay to inspect the index of a series (or data frame)
songs2.index
songs2
""" it give the  index value by default
Out[30]: 
0    334
1    355
2     54
3     76
Name: counts, dtype: int64"""

##########################################################
#assign index as the index can be string based as well in which case pandas indicates that the datatype for the index is object (not string):
songs3=pd.Series([334,355,54,76],name='counts',
                index=['paul','john','ingo','tipa'])
songs3.index				#intialise
#it give the index to counts column i.e. index
songs3
"""Out[28]: 
paul    334
john    355
ingo     54
tipa     76
Name: counts, dtype: int64"""

####################################################
#the nan valuestands for 
#numeric column will become  nan/null
import pandas as pd
f1=pd.read_csv("C:/Data Science/1-python/courses.csv")
f1
#finding the mean value
import pandas as pd
songs = pd.Series([145,25,36,78],name = 'count')
songs
#It is easy to inspect the index of a series(or a dataframe)
songs.index
#the index non be string bases as well,in which case pandas indicates  that the datatype for the index is object (not string):

songs3 = pd.Series([154,35,41,26,47],name='count',index=['Arijit','Honey','Atif','Shreya','Ajay'])
songs3

#NaN - it is generally ignored in arithmetic operation the series object behaves similarly to a numpy array
songs3.mean()
songs3

#################################################
##pandas series Data structure provides the support for the CRUD operation
#creation
george=pd.Series([23,45,54,7],
                 index=['3245','5665','5646','5465'],
                 name='George songs')
george

##############################################
#reading:-to read  or select the data frame a series
george['3245']
george['5665']
#it can show the index value which has the value assign to it and show that value
# we can iterate over in 
for item in george:
    print(item)
   #o.p:- """23
    45
    54
    7"""
    # it shows only value

############################################################
#updateing
#updating the value sin series little trickle as well as to update the value
george['3245']=68
george=['3245']
george['3245']

#########################################################
#deletion
# the del statement appers to have problem with duplicatae value index
s=pd.Series([2,3,4],index=[1,2,3])
del s[1]
s

#########################################################
# converrt types
#string use .astype(str)
#numeric use pd.numeric
#innteger use .astype(int)
# note a
#
import pandas as pd
songs_66=pd.Series([3,None,11,9],
                   index=['a','s','d','f'],
                   name='Counts')

pd.to_numeric(songs_66.apply(str))
#ther will be error
#that error can be solve by uing the errors='coerce'

pd.to_numeric(songs_66.apply(str),errors='coerce')
#it can remove the error occur in teh series 
#dealing with none

################################################



#dealing with none
songs_66.fillna[-1]
#drop the null data 
songs_66.dropna()

###############################################
#append combine and joining the tow series
import pandas as pd
songs_69=pd.Series([7,56,34,1],
                   index=['aa','ss','dd','ff'],
                   name='Counts')
#the concactnet  the tow series together we use simply append()
songs=songs_66.append(songs_69)

####pandas series opertion
#Write a Pandas program to create and display a one-dimensional array-like object 
#containing an array of data.
import pandas as pd
ds = pd.Series([2, 4, 6, 8, 10])
print(ds)

###################################################
#Write a Pandas program to convert a Panda module Series
# to Python list and it’s type.
import pandas as pd
ds = pd.Series([2, 4, 6, 8, 10])
print("Pandas Series and type")
print(ds)
print(type(ds))
print("Convert Pandas Series to Python list")
print(ds.tolist())
print(type(ds.tolist()))

#######################################################
#Write a Pandas program to add, subtract, multiple and divide two Pandas Series.
#Sample Series: [2, 4, 6, 8, 10], [1, 3, 5, 7, 9]
import pandas as pd
ds1 = pd.Series([2, 4, 6, 8, 10])
ds2 = pd.Series([1, 3, 5, 7, 9])
ds = ds1 + ds2
print("Add two Series:")
print(ds)
‘’’ 0     3
1     7
2    11
3    15
4    19
dtype: int64’’’’
print("Subtract two Series:")
ds = ds1 - ds2
print(ds)
‘’’ 0    1
1    1
2    1
3    1
4    1
dtype: int64’’’’
print("Multiply two Series:")
ds = ds1 * ds2
print(ds)
‘’’’ 0     2
1    12
2    30
3    56
4    90
dtype: int64’’’’
print("Divide Series1 by Series2:")
ds = ds1 / ds2
print(ds)
‘’’’ 0    2.000000
1    1.333333
2    1.200000
3    1.142857
4    1.111111
dtype: float64’’’’

####################################################################
#Write a Pandas program to compare the elements of the two Pandas Series.
#Sample Series: [2, 4, 6, 8, 10], [1, 3, 5, 7, 10]
import pandas as pd
ds1 = pd.Series([2, 4, 6, 8, 10])
ds2 = pd.Series([1, 3, 5, 7, 10])
print("Series1:")
print(ds1)
‘’’’ 0     2
1     4
2     6
3     8
4    10
dtype: int64’’’’
print("Series2:")
print(ds2)
‘’’’ 0     1
1     3
2     5
3     7
4    10
dtype: int64’’’’
print("Compare the elements of the said Series:")
print("Equals:")
print(ds1 == ds2)
‘’’’ 0    False
1    False
2    False
3    False
4     True
dtype: bool’’’’
print("Greater than:")
print(ds1 > ds2)
‘’’’’ 0     True
1     True
2     True
3     True
4    False
dtype: bool’’’’
print("Less than:")
print(ds1 < ds2)
‘’’’ 0    False
1    False
2    False
3    False
4    False
dtype: bool’’’’’

#######################################################
#Write a Pandas program to convert a dictionary to a Pandas series.
#Original dictionary:{'a': 100, 'b': 200, 'c': 300, 'd': 400, 'e': 800}
import pandas as pd
d1 = {'a': 100, 'b': 200, 'c':300, 'd':400, 'e':800}
print("Original dictionary:")
print(d1)		#{'a': 100, 'b': 200, 'c': 300, 'd': 400, 'e': 800}
new_series = pd.Series(d1)
print("Converted series:")	
print(new_series)
‘’’ a    100
b    200
c    300
d    400
e    800
dtype: int64’’’’’

####################################
#Write a Pandas program to convert a NumPy array to a Pandas series. 
import numpy as np
import pandas as pd
n_a = np.array([10, 20, 30, 40, 50])
print("NumPy array:")
print(n_a)		# [10 20 30 40 50]
new_series = pd.Series(n_a)
print("Converted Pandas series:")
print(new_series)
‘’’’ 0    10
1    20
2    30
3    40
4    50
dtype: int32’’’’
########################################
#Write a Pandas program to change the data type of given a column or a Series. 
'''
Sample Series:
Original Data Series:
0 100
1 200
2 python
3 300.12
4 400
dtype: object
Change the said data type to numeric:
0 100.00
1 200.00
2 NaN
3 300.12
4 400.00
dtype: float64
'''
import pandas as pd
s1 = pd.Series(['100', '200', 'python', '300.12', '400'])
print("Original Data Series:")
print(s1)
print("Change the said data type to numeric:")
s2 = pd.to_numeric(s1, errors='coerce')
print(s2)
#######################################3
#Write a Pandas program to convert 
#the first column of a DataFrame as a Series. 
import pandas as pd
d = {'col1': [1, 2, 3, 4, 7, 11],
     'col2': [4, 5, 6, 9, 5, 0], 
     'col3': [7, 5, 8, 12, 1,11]
     }
df = pd.DataFrame(data=d)
print("Original DataFrame")
print(df)
s1 = df.iloc[:,0]
print("\n1st column as a Series:")
print(s1)
print(type(s1))

###################################
import pandas as pd
s = pd.Series([
    ['Red', 'Green', 'White'],
    ['Red', 'Black'],
    ['Yellow']])
print("Original Series of list")
print(s)
s = s.apply(pd.Series).stack().reset_index(drop=True)
print("One Series")
print(s)






DataFrame - stack() function
The stack() function is used to stack the prescribed level(s) from columns to index.
Return a reshaped DataFrame or Series having a multi-level index with one or more new inner-most levels compared to the current DataFrame. The new inner-most levels are created by pivoting 
 the columns of the current dataframe:    if the columns have a single level, the output is a Series;    if the columns have multiple levels, the new index level(s) is (are) taken from the  prescribed level(s) and the output is a DataFrame. 
################################
#Write a Pandas program to sort a given Series. 
import pandas as pd
s = pd.Series(['100', '200', 'python', '300.12', '400'])
print("Original Data Series:")
print(s)
‘’’ 0       100
1       200
2    python
3    300.12
4       400
dtype: object’’’’
new_s = pd.Series(s).sort_values()
print(new_s)
‘’’ 0       100
1       200
3    300.12
4       400
2    python
dtype: object’’’’’’’

###################################################
#Write a Pandas program to add some data 
#to an existing Series. 
import pandas as pd
s = pd.Series(['100', '200', 'python', '300.12', '400'])
print("Original Data Series:")
print(s)
‘’’ 0       100
1       200
2    python
3    300.12
4       400
dtype: object’’’
print("\nData Series after adding some data:")
new_s = pd.concat([s, pd.Series([500, "php"])], ignore_index=True)
print(new_s)
‘’’ 0       100
1       200
2    python
3    300.12
4       400
5       500
6       php
dtype: object’’’

####################################
#Write a Pandas program to change the order of index
# of a given series.
'''
Sample Output:
Original Data Series:
A    1
B    2
C    3
D    4
E    5
dtype: int64
Data Series after changing the order of index:
B    2
A    1
C    3
D    4
E    5
dtype: int64

'''
import pandas as pd
s = pd.Series(data = [1,2,3,4,5], index = ['A', 'B', 'C','D','E'])
print("Original Data Series:")
print(s)
s = s.reindex(index = ['B','A','C','D','E'])
print("Data Series after changing the order of index:")
print(s)

######################################3




**********************graph draw***************************
#Matplotlip:- it is used to plot the graph,,,, first install the matplotlip i.e. as like a pandas 
1. wite the command “pip install matplotlip”
#plaoting the two series
import matplotlib.pyplot as plt
flg=plt.figure()
songs_69.plot()
plt.legend()
#o.p:- 
Write the description of the above code and all the below code
###################################
#for studing the bar graph for plotings the series
flg=plt.figure()
songs_69.plot(kind='bar')
songs_66.plot(kind='bar',color='k',alpha=.5)
plt.legend()
#o.p:- 

##########################################
#hextogram
import numpy as np
data=pd.Series(np.random.randn(500),
name='500 random')
flg=plt.figure()
ax=flg.add_subplot(111)
data.hist()#o.p:- 
************************use of numpy*********************
#What is NumPy?
#The NumPy library is a popular open-source Python library used for scientific computing applications, and it stands for Numerical Python, which is consisting of multidimensional array objects and a collection of routines for processing those arrays.
1. it is used to working on the array i.e. is matrix  Column feature dimension
2. Dimensitonality reduction reduce the large column in small column or less number of column  matrix reduction and develop the model so we required numpy 

#Install Python NumPy Library
1)	goto base terminal and on prompt
2)	pip install numpy
3)	Install NumPy using Conda
4)	conda install numpy

# While a Python list can contain different data types within a single list,all of the elements in a NumPy array should be homogeneous.

#Arrays In NumPy
# Create ndarray
import numpy as np
arr = np.array([10,20,30]) 
print (arr)
# Output : [10 20 30]

#######################################################
#Create a Multi-Dimensional Array
arr = np.array([[10,20,30],[40,50,60]]) 
print (arr)
# Output :
[[10 20 30]
 [40 50 60]]

#######################################################
#Represent The Minimum Dimensions
#Use ndmin param to specify how many minimum dimensions you wanted to create an array withaccording to the [] square bracket we can define the dimension of the array dimension to create an array with an minimum dimension ndmin
# Minimum dimension
arr = np.array([10, 20, 30,40], ndmin = 2) 
print (arr) 
 # Output: 
[[10 20 30 40]]-- 	2 dimension array accourindig to the square bracket

###########################################################
arr = np.array([10, 20, 30,40], ndmin = 3) 
print (arr)
 # Output: [[[10 20 30 40]]]

#########################################################
#Change The Data Type using the dtype parameter 
arr = np.array([10, 20, 30], dtype = complex) 
print(arr)
# Output :[10.+0.j 20.+0.j 30.+0.j]

#######################################################
#Get The Dimensions of Array
arr = np.array([[1, 2, 3, 4], [7, 8, 6, 7], [9, 10, 11, 12]])  
print(arr. ndim) 
print(arr)
#Outputs :2
[[ 1  2  3  4]
 [ 7  8  6  7]
 [ 9 10 11 12]]

######################################################
# Finding the size of each item in the array  
arr = np.array([10,20,30])
print("Each item contain in bytes :",arr.itemsize)  
#Outputs:Each item contain in bytes: 4

#######################################################
#Get The Data Type of Each Array Item
# Finding the data type of each array item  
arr = np.array([10,20,30])  
print("Each item is of the type", arr.dtype)
# Output:Each item is of the type int32

#######################################################
#Get the Shape and Size of Array
arr = np.array([[10,20,30,40],[60,70,80,90]])  
print("Array Size:", arr.size)  
print("Shape:", arr.shape)
#o.p:-Array Size: 8
#Shape: (2, 4)

##################################################
#Create NumPy Array From List
# Creation of Arrays
arr = np.array([10, 20, 30])
print("Array:",arr)			#o.p:- Array: [10 20 30]
#################################################
# Creating array from list with type float
arr = np.array([[10, 20, 40], [30,40,50]], dtype = 'float')
print ("Array created by using list: \n", arr)
# Output: Array created by using list: 
 [[10. 20. 40.]
 [30. 40. 50.]]

###################################################
#Create a Sequence of Integers using arange()
# Create a sequence of integers from 0 to 20 with steps of 3
arr= np.arange(0, 20, 3)
print ("A sequential array with steps of 3:\n", arr)
#Array Indexing in NumPy
# Output: A sequential array with steps of 3:[ 0  3  6  9 12 15 18]

################################################
# Access single element using index 
arr = np.arange(11)
print(arr)
#[ 0  1  2  3  4  5  6  7  8  9 10]
print(arr[2])
#2
print(arr[-2])
#9

###########################################################
#Multi-Dimenstional Array Indexing
# Access multi-dimensional array element using array indexing
arr =np.array([[10,20,30,40,50],[20,30,50,10,30]])
print(arr)
#o.p:-[[10 20 30 40 50]
 [20 30 50 10 30]]

print(arr.shape)
#o.p:-(2,5) # now x is 2-dimensional

print(arr[1,1])
#30
print(arr[0,4])
#50
print(arr[1,-1])#rows starts from 0,we need 1 st row and last column
#30

##################################################

# Access array elements using slicing
arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
x= arr[1:8:2]   #start:end:in step of 2
print(x)
# Output: [1 3 5 7]

#################################################
# Example
x=arr[-2:3:-1]#start last but one(-2) upto 3 but not 3 in step of -1
print(x)
# Output: [8 7 6 5 4]

################################################## 
# Example
x=arr[-2:10]#start last but one(-2) and upto 10 but not 10
print(x)
#[8 9]

######################################################
# indexing in numpy
multi_arr = np.array([[10, 20, 10, 40],
        [40, 50, 70, 90],
            [60, 10, 70, 80],
        [30, 90, 40, 30]])
Arr

#############################################
# Slicing array
#For multi-dimensional NumPy arrays, 
#you can access the elements as below

multi_arr [1, 2] #– To access the value at row 1 and column 2.
multi_arr [1,:] #– To get the value at row 1 and all columns.
multi_arr [:, 1] #– Access the value at all rows and columns 1.

###############################################
x= multi_arr[:3, ::2] #columns from 0 to 3,in all selected rows and column every alternate rows
print (x)
# Output : 
# [[10 10]
# [40 70]
# [60 70]]

###############################################


#Integer Array Indexing
Integer array indexing allows the selection of arbitrary items in the array based on their N-dimensional index. Each integer array represents a number of indices into that dimension. In this method, lists are passed for indexing for each dimension. One to one mapping of corresponding elements is done to construct a new arbitrary array.

# Integer array indexing
arr = np.arange(35).reshape(5, 7)
print(arr)
‘’’ [[ 0  1  2  3  4  5  6]
 [ 7  8  9 10 11 12 13]
 [14 15 16 17 18 19 20]
 [21 22 23 24 25 26 27]
 [28 29 30 31 32 33 34]]’’’

###########################################################
# Boolean Array Indexing
#This advanced indexing occurs when an object is an array object of Boolean types, such as may be returned from comparison operators. Use this method when we want to pick elements from the array which satisfy some conditions.
# Boolean array indexing
arr = np.arange(12).reshape(3,4)
print(arr)
#o.p:-
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]

###############################################
rows = np.array([False,True,True])#not 0th row only first and second row
wanted_rows= arr[rows, : ]#In selected rows all rows and columns
print(wanted_rows)
#o.p:-
[[ 4  5  6  7]
 [ 8  9 10 11]]

####################################################
#Convert NumPy Array to Python List
We can convert the Numpy array to the list by using tolist() method, We may have a list of data elements that have been converted from the array using this method.
# Convert One Dimensional Array To List
# create array
array = np.array([10, 20, 30, 40])  
print("Array:", array)
print(type(array))
#Array: [10 20 30 40]
#######################################################
# Convert list
lst = array.tolist()
print("list:", lst)
print(type(lst))
#list: [10, 20, 30, 40]

#######################################################3
# Convert Multi Dimensional Array to list
# create array
array = np.array([[10, 20, 30, 40],
                  [50, 60, 70, 80],
                  [60, 40 ,20 ,10]])  
print("Array:", array)
#Array: [[10 20 30 40]
 [50 60 70 80]
 [60 40 20 10]]

#######################################################
# Convert list
lst = array.tolist()
print("list:", lst)
#o.p:-list: [[10, 20, 30, 40], [50, 60, 70, 80], [60, 40, 20, 10]]

###################################################
# Convert Python List to A NumPy Array
Lists can convert to arrays using the built-in functions in the Python NumPy library.
#How to convert a list to an array in Python
NumPy provides us with two functions to use when converting a list into an array:
1.	numpy.array()
2.	numpy.asarray()
#numpy.array() : Using numpy.array() This function of the numpy library allows a list as an argument and returns an array that contains all the elements of the list. See the example below: import numpy as np. …
# Create list
list = [20,40,60,80]
# Convert array
array = np.array(list)
print ("Array:", array)
# Output: Array: [20 40 60 80]

########################################################
#numpy.asarray() : Using numpy.asarray() This function calls the numpy.array() function inside itself.
# Use asarray()
list = [20,40,60,80]
array = np.asarray(list)
print(" Array:", array)
print(type(array))
# Output : Array: [20 40 60 80]

#######################################################
# Numpy Array Properties 
1)	ndarray.shape
2)	ndarray.ndim
3)	ndarray.itemsize
4)	ndaray.size
5)	ndarray.dtype

#ndarray.shape
#To get the shape of a Python NumPy array use numpy.ndarray.shape property. The array shape can be defined as the number of elements in each dimension and dimension is defined as a number of indices or subscripts, that can specify an individual element of an array.shape attribute returns a tuple consisting of array dimensions. It can also use to resize the array. For example,
#Shape
array = np.array([[1,2,3],[4,5,6]]) 
print(array.shape)
# Output :(2, 3)

#########################################################
# Resize the array
array = np.array([[10,20,30],[40,50,60]]) 
array.shape=(3,2)
print(array)

# Output:
[[10 20]
 [30 40]
 [50 60]]

####################################################
#NumPy also provides a numpy.reshape() function to resize an array. For example:-
#reshape usage
array = np.array([[10,20,30],[40,50,60]]) 
new_array = array.reshape(3,2)
print(new_array)

# Output : 
[[10 20]
 [30 40]
 [50 60]]

#############################################
# ndarray.ndim
The ndim property is used to find the dimensions of the array.
# Usage of ndim
array = np.array([[1, 2, 3, 4], 
                  [7, 8, 6, 7], 
                  [9, 10, 11, 12]])  
print(array.ndim) 
#Outputs :2

##################################################
#ndarray.itemsize
#The itemsize property is used to get the size of each array item. It returns the number of bytes taken by each array element.
# Finding the size of each item in the array  
array = np.array([10,20,30])
print("Each item contain in bytes :",array.itemsize)  
#Outputs:Each item contain in bytes: 4

##################################################
# ndarray.dtype
#Use dtype function to check the data type of each array item.  
# Finding the data type of each array item  
array = np.array([10,20,30])  
print("Each item is of the type", array.dtype)
#Output:Each item is of the type int32

##################################################
# ndaray.size
#To get the shape and size of the array,the size and shape function associated with the numpy array is used. 
# Get shape and size of array
array = np.array([[10,20,30,40],[60,70,80,90]])  
print("Array Size:", array.size)  
print("Shape:", array.shape)

# Output:Array Size: 8
Shape: (2, 4)

#####################################################
# Operations Using in NumPy 
#NumPy’s operations are divided into three main
# categories:

1)	Fourier Transform and Shape Manipulation
2)	Mathematical and Logical Operations
3)	Linear Algebra and Random Number Generation.
# Arithmetic Operations
Arithmetic operators on arrays apply elementwise. A new array is created and filled with the result.
# Apply arithmetic operations on numpy arrays
arr1 = np.arange(16).reshape(4,4)
arr2 = np.array([1, 3, 2, 4])

# add()
add_arr = np.add(arr1,arr2)
print(f"Adding two arrays:\n{add_arr}")
#Adding two arrays:
# [[ 1  4  4  7]
# [ 5  8  8 11]
# [ 9 12 12 15]
# [13 16 16 19]]

##################################################
# substract()
sub_arr=np.subtract(arr1,arr2)
print(f"Subtracting two arrays:\n{sub_arr}")
#Subtracting two arrays:
# [[-1 -2  0 -1]
# [ 3  2  4  3]
# [ 7  6  8  7]
# [11 10 12 11]]

##################################################
# multiply()
mul_arr = np.multiply(arr1, arr2)
print(f"multiplying two arrays:\n{mul_arr}")
#Multiplying the two arrays:
# [[ 0  3  4 12]
# [ 4 15 12 28]
# [ 8 27 20 44]
# [12 39 28 60]]

#################################################
# divide()
div_arr = np.divide(arr1, arr2)
print(f"Dividing two arrays:\n{div_arr}")
#Dividing the two arrays:
# [[ 0.          0.33333333  1.          0.75      ]
# [ 4.          1.66666667  3.          1.75      ]
# [ 8.          3.          5.          2.75      ]
# [12.          4.33333333  7.          3.75      ]]

##################################################
# numpy.reciprocol()
This function returns the reciprocal of argumentelement-wise. For elements with absolute values larger than 1, the result is always 0 because of the way in which Python handles integer division. For integer 0, an overflow warning is issued.

# To perform Reciprocal operation
arr1 = np.array([50, 10.3, 5, 1, 200])
rep_arr1=np.reciprocal(arr1)
print(f"After applying reciprocal function to array:\n{rep_arr1}")
#o.p:-After applying reciprocal function:
# [0.02       0.09708738 0.2        1.         0.005     ]

###############################################
# numpy.power()
This NumPy power() function treats elements in the first input array as the base and returns it raised to the power of the corresponding element in the second input array.

# To perform power operation
arr1 = np.array([3, 10, 5])
pow_arr1 = np.power(arr1, 3)
print(f"After applying power function to array:\n{pow_arr1}")
#o.p:-Applying power function:
# [  27 1000  125]

arr2 = np.array([3, 2, 1])
print("My second array:\n",arr2)
pow_arr2=np.power(arr1, arr2)
print(f"After applying power function to array:\n{pow_arr2}")
#o.p:-Applying power function again:
# [ 27 100   5]

#################################################
# numpy.mod()
This function returns the remainder of the division of the corresponding elements in the input array. The function numpy.remainder() also produces the same result.
# To perform mod function
# on NumPy array
import numpy as np
arr1 = np.array([7, 20, 13])
arr2 = np.array([3, 5, 2])
arr1
arr1.dtype
# mod()
mod_arr = np.mod(arr1, arr2)
print(f"After applying mod function to array:\n{mod_arr}")
#o.p:- Applying mod() function: [1 0 1]
##########################################

# remainder()
rem_arr = np.remainder(arr1, arr2)
print(f"After applying remainder function to array:\n{rem_arr}")
#o.p:-Applying remainder() function: [1 0 1]








#################opertion on array and matrix
# create array
from numpy import array
# create array
l = [1.0, 2.0, 3.0]
a = array(l)
# display array
print(a)        #o.p:-[1. 2. 3.]
# display array shape
print(a.shape)  #o.p:-(3,)
# display array data type
print(a.dtype)      #o.p:-float64

################################################
# create empty array
from numpy import empty
a = empty([3,3])
print(a)
'''
[[4.67296746e-307 1.69121096e-306 1.24610994e-306]
 [1.42413555e-306 1.78019082e-306 1.37959740e-306]
 [6.23057349e-307 1.42419530e-306 3.91786943e-317]]
'''
########################################
# create zero array
from numpy import zeros
a = zeros([3,5])
print(a)
'''
[[0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0.]]
'''
###########################################
# create one array
from numpy import ones
a = ones([5])
print(a)        #o.p:-[1. 1. 1. 1. 1.]

#########################################
# create array with vstack
from numpy import array
from numpy import vstack
# create first array
a1 = array([1,2,3])
print(a1)               #o.p:-[1 2 3]
# create second array
a2 = array([4,5,6])
print(a2)               #o.p:-[4 5 6]
# vertical stack
a3 = vstack((a1, a2))
print(a3)               #o.p:-[[1 2 3] [4 5 6]]
print(a3.shape)         #o.p:-(2, 3)

#############################################
# create array with hstack
from numpy import array
from numpy import hstack
# create first array
a1 = array([1,2,3])
print(a1)               #o.p:-[1 2 3]
# create second array
a2 = array([4,5,6])
print(a2)               #o.p:-[4 5 6]
# create horizontal stack
a3 = hstack((a1, a2))
print(a3)               #o.p:-[1 2 3 4 5 6]
print(a3.shape)         #o.p:-(6,)

######################################################
#One-Dimensional List to Array
# create one-dimensional array
from numpy import array
# list of data
data = [11, 22, 33, 44, 55]
# array of data
data = array(data)
print(data)     #o.p:-[11 22 33 44 55]
print(type(data))       #o.p:-<class 'numpy.ndarray'>

######################################################
#Two-Dimensional List of Lists to Array
# create two-dimensional array
from numpy import array
# list of data
data = [[11, 22],
[33, 44],
[55, 66]]
# array of data
data = array(data)
print(data)
'''o.p:-[[11 22]
 [33 44]
 [55 66]]'''
print(type(data))           #o.p:-<class 'numpy.ndarray'>

###################################################
# index a one-dimensional array
from numpy import array
# define array
data = array([11, 22, 33, 44, 55])
# index data
print(data[0])          #o.p:-11
print(data[4])          #o.p:-55

################################################
# index array out of bounds
from numpy import array
# define array
data = array([11, 22, 33, 44, 55])
# index data
print(data[5])
#IndexError: index 5 is out of bounds for axis 0 with size 5

##################################################
# negative array indexing
from numpy import array
# define array
data = array([11, 22, 33, 44, 55])
# index data
print(data[-1])         #o.p:-55
print(data[-5])         #o.p:-11

##################################################
# index two-dimensional array
from numpy import array
# define array
data = array([
[11, 22],
[33, 44],
[55, 66]])
# index data
print(data[0,0])        #o.p:-11

###########################################



# index row of two-dimensional array
from numpy import array
# define array
data = array([
[11, 22],
[33, 44],
[55, 66]])
# index data
print(data[0,])#o th row and all columns
#[11 22]

##########################################
# slice a one-dimensional array
from numpy import array
# define array
data = array([11, 22, 33, 44, 55])
print(data[1:4])
#[22 33 44]

###################################################
# negative slicing of a one-dimensional array
from numpy import array
# define array
data = array([11, 22, 33, 44, 55])
print(data[-2:])            #o.p:-[44 55]

##################################################
# split input and output data
from numpy import array
# define array
data = array([
[11, 22, 33],
[44, 55, 66],
[77, 88, 99]])
# separate data
X, y = data[:, :-1], data[:, -1]
#data[:, :-1]-all rows and all columns
#except all rows and last column
#data[:, -1]-taking all rows (:) 
#but keeping the last column (-1)
print(X)
'''o.p:-[[11 22]
 [44 55]
 [77 88]]'''
print(y)        #o.p:-[33 66 99]
###########################################
# broadcast scalar to one-dimensional array
from numpy import array
# define array
a = array([1, 2, 3])
print(a)        #o.p:-[1 2 3]
# define scalar
b = 2           #o.p:-2
print(b)
# broadcast
c = a + b
print(c)        #o.p:-[3 4 5]

################################################
# vector addition
from numpy import array
# define first vector
a = array([1, 2, 3])
print(a)        #o.p:-[1 2 3]
# define second vector
b = array([1, 2, 3])
print(b)                #o.p:-[1 2 3]
# add vectors
c = a + b
print(c)                #o.p:-[2 4 6]

############################################
# vector subtraction
from numpy import array
# define first vector
a = array([1, 2, 3])
print(a)            #o.p:-[1 2 3]
# define second vector
b = array([0.5, 0.5, 0.5])
print(b)            #o.p:-[0.5 0.5 0.5]
# subtract vectors
c = a - b
print(c)            #o.p:-[0.5 1.5 2.5]

###########################################
# vector L1 norm
from numpy import array
from numpy.linalg import norm
# define vector
a = array([1, 2, 3])
print(a)            #o.p:-[1 2 3]
# calculate norm
l1 = norm(a, 1)
print(l1)       #o.p:-6.0

############################################
# vector L2 norm
from numpy import array
from numpy.linalg import norm
# define vector
a = array([1, 2, 3])
print(a)            #o.p:-[1 2 3]
# calculate norm
l2 = norm(a)
print(l2)           #o.p:-3.7416573867739413

################################################
# triangular matrices
from numpy import array
from numpy import tril
from numpy import triu
# define square matrix
M = array([
[1, 2, 3],
[1, 2, 3],
[1, 2, 3]])
print(M)
'''o.p:-[[1 2 3]
 [1 2 3]
 [1 2 3]]'''
# lower triangular matrix
lower = tril(M)
print(lower)
'''o.p:-[[1 0 0]
 [1 2 0]
 [1 2 3]]'''
# upper triangular matrix
upper = triu(M)
print(upper)
'''o.p:-[[1 2 3]
 [0 2 3]
 [0 0 3]]'''

##############################################
# diagonal matrix
from numpy import array
from numpy import diag
# define square matrix
M = array([
[1, 2, 3],
[1, 2, 3],
[1, 2, 3]])
print(M)
'''o.p:-[[1 2 3]
 [1 2 3]
 [1 2 3]]'''
# extract diagonal vector
d = diag(M)
print(d)
#o.p:-[1 2 3]
# create diagonal matrix from vector
D = diag(d)
print(D)
'''o.p:-[[1 0 0]
 [0 2 0]
 [0 0 3]]'''

#############################################
#identity matrix
from numpy import identity
I = identity(3)
print(I)
'''o.p:-[[1. 0. 0.]
 [0. 1. 0.]
 [0. 0. 1.]]'''

##############################################
# orthogonal matrix
from numpy import array
from numpy.linalg import inv
# define orthogonal matrix
Q = array([
[1, 0],
[0, -1]])
print(Q)
'''o.p:-[[ 1  0]
 [ 0 -1]]'''
# inverse equivalence
V = inv(Q)
print(Q.T)
'''o.p:-
[[ 1  0]
 [ 0 -1]]'''
print(V)
'''o.p:-[[ 1.  0.]
 [-0. -1.]]'''

###################
# identity equivalence
I = Q.dot(Q.T)
print(I)
'''o.p:-[[1 0]
 [0 1]]'''

########################################
# transpose matrix
from numpy import array
# define matrix
A = array([
[1, 2],
[3, 4],
[5, 6]])
print(A)            #o.p:- it will print the array
# calculate transpose
C = A.T
print(C)
'''o.p:-[[1 3 5]
 [2 4 6]]'''

##########################################
# invert matrix
from numpy import array
from numpy.linalg import inv
# define matrix
A = array([
[1.0, 2.0],
[3.0, 4.0]])
print(A)            #o.p:- it gove the above matrix
# invert matrix
B = inv(A)
print(B)
'''o.p:-[[-2.   1. ]
 [ 1.5 -0.5]]'''
# multiply A and B
I = A.dot(B)
print(I)
'''o.p:-[[1.00000000e+00 1.11022302e-16]
 [0.00000000e+00 1.00000000e+00]]'''
###########################################

# sparse matrix
from numpy import array
from scipy.sparse import csr_matrix
# create dense matrix
A = array([
[1, 0, 0, 1, 0, 0],
[0, 0, 2, 0, 0, 1],
[0, 0, 0, 2, 0, 0]])
print(A)                #o.p:-it will give the above array
# convert to sparse matrix (CSR method)
S = csr_matrix(A)
print(S)
'''o.p:-  (0, 0)	1
  (0, 3)	1
  (1, 2)	2
  (1, 5)	1
  (2, 3)	2'''
# reconstruct dense matrix
B = S.todense()
print(B)
'''o.p:-[[1 0 0 1 0 0]
 [0 0 2 0 0 1]
 [0 0 0 2 0 0]]'''

##############################################
from numpy import array
T = array([
[[1,2,3], [4,5,6], [7,8,9]],
[[11,12,13], [14,15,16], [17,18,19]],
[[21,22,23], [24,25,26], [27,28,29]]])
print(T.shape)                  #o.p:-(3, 3, 3)
print(T)
'''o.p:-[[[ 1  2  3]
  [ 4  5  6]
  [ 7  8  9]]

 [[11 12 13]
  [14 15 16]
  [17 18 19]]

 [[21 22 23]
  [24 25 26]
  [27 28 29]]]'''



	Matplotlib
                                 Matplotlib is an amazing visualization library in Python for 2D plots of arrays. Matplotlib is a multi-platform data visualization library built on NumPy arrays and designed to work with the broader SciPy stack. It was introduced by John Hunter in the year 2002. One of the greatest benefits of visualization is that it allows us visual access to huge amounts of data in easily digestible visuals. Matplotlib consists of several plots like line, bar, scatter, histogram etc.
•	  Create publication quality plots.
•	Make interactive figures that can zoom, pan, update.
•	Customize visual style and layout.
•	Export to many file formats.
•	Embed in JupyterLab and Graphical User Interfaces.
•	Use a rich array of third-party packages built on Matplotlib.
	Pyplot :
                       Pyplot is a Matplotlib module that provides a MATLAB-like interface. Matplotlib is designed to be as usable as MATLAB, with the ability to use Python and the advantage of being free and open-source. Each pyplot function makes some changes to a figure: e.g., creates a figure, creates a plotting area in a figure, plots some lines in a plotting area, decorates the plot with labels, etc. The various plots we can utilize using Pyplot are Line Plot, Histogram, Scatter, 3D Plot, Image, Contour, and Polar.

import matplotlib.pyplot as plt
plt.plot([1, 3, 2, 4]) --------------------------------------------------------------------------
plt.show()

##################################
#Multiline plots
import matplotlib.pyplot as plt
x = range(1, 5)
plt.plot(x, [xi*1.5 for xi in x])-------------------------

plt.plot(x, [xi/3.0 for xi in x])-------------------------------------------------------------
plt.show()

####################################
#Note how Matplotlib automatically chooses different colors for each line—green for 
#the first line, blue for the second line, and red for the third one (from top to bottom).

########################################
#Grid, axes, and labels
#Adding a grid
import matplotlib.pyplot as plt
import numpy as np
x = np.arange(1, 5)
plt.plot(x, x*1.5, x, x*3.0, x, x/3.0)-------------------------------------------------------

plt.grid(True)------------------------------------------
plt.show()

################################
#Handling axes
import matplotlib.pyplot as plt 
import numpy as np 
x = np.arange(1, 5) 
plt.plot(x, x*1.5, x, x*3.0, x, x/3.0) ----------------------------------------------
 
plt.axis() -------------------------------------------
# shows the current axis limits values




plt.axis([0, 5, -1, 13]) # set new axes limits --------------------------------------
# [xmin,xmax, ymin, ymax]
#[0, 5, -1, 13] 
plt.show()

#####################################
#Adding labels
import matplotlib.pyplot as plt 
plt.plot([1, 3, 2, 4]) -------------------------------
 



plt.xlabel('This is the X axis') -----------------------------------------------------------
 
plt.ylabel('This is the Y axis') --------------------
plt.show() 

#####################################
#Adding a title
import matplotlib.pyplot as plt 
plt.plot([1, 3, 2, 4]) ---------------------------------------------------------------------

plt.title('Simple plot') ---------------------------
plt.show()

#Matplotlib provides a simple function, 
plt.title(), to add a title to an image
#==================================
#Adding a legend
import matplotlib.pyplot as plt 
import numpy as np 
x = np.arange(1, 5)
plt.plot(x, x*1.5, label='Normal') --------
 

plt.plot(x, x*3.0, label='Fast') -------------------------------------------------
 
plt.plot(x, x/3.0, label='Slow') --------------------------------------------------
 
plt.legend() -------------------
 
plt.show()



#############################
#Control colors
import matplotlib.pyplot as plt 
import numpy as np 
y = np.arange(1, 3) 
plt.plot(y, 'y'); -------------------------

plt.plot(y+1, 'm');---------------------------------------------------------------

plt.plot(y+2, 'c');------------------
plt.show()

##########################
'''Color abbreviation
Color Name
b     blue
c     cyan
g     green
k     black
m     magenta
r     red
w     white
y     yellow
'''
#Specifying styles in multiline plots
import matplotlib.pyplot as plt 
import numpy as np 
y = np.arange(1, 3) 
plt.plot(y, 'y', y+1, 'm', y+2, 'c');--------
plt.show()

#=========================================

#Control line styles
import matplotlib.pyplot as plt 
import numpy as np 
y = np.arange(1, 3) 
plt.plot(y, '--', y+1, '-.', y+2, ':');----------------
plt.show()

##################################
'''
Style abbreviation Style
- solid line
-- dashed line
-. dash-dot line
: dotted line
'''
#===================================================
#Control marker styles
Marker abbreviation Marker style
•	. Point marker
•	, Pixel marker
•	Circle marker
•	v Triangle down marker
•	^ Triangle up marker
•	< Triangle left marker
•	Triangle right marker
1.	 Tripod down marker
2.	 Tripod up marker
3.	 Tripod left marker
4.	 Tripod right marker
5.	 Square marker
6.	P Pentagon marker
7.	* Star marker
8.	h Hexagon marker
9.	H Rotated hexagon marker
10.	+ Plus marker
11.	x Cross (x) marker
12.	D Diamond marker
13.	d Thin diamond marker
14.	| Vertical line (vline symbol) marker

import matplotlib.pyplot as plt
import numpy as np
y = np.arange(1, 3, 0.2)
plt.plot(y, 'x', y+0.5, 'o', y+1, 'D', y+1.5, '^', y+2, 's');---
plt.show()

#########################################


#Histogram charts
import matplotlib.pyplot as plt 
import numpy as np 
y = np.random.randn(1000)
plt.hist(y);-------------------------
plt.show()

####################
import matplotlib.pyplot as plt
plt.bar([1, 2, 3], [3, 2, 5]);--------------------------------------------------
plt.show()

'''
The bar() function is used to generate bar charts in Matplotlib. 
The function expects two lists of values: 
the X coordinates that are the positions of the bar's left margin and the heights of the bars:
 As we can see  the left margin of the bars start at the points specified in the first list, while their heights are the values of the second list.    
'''
#=======================================================
#Scatter plots
'''
Bivariate analysis
Scatter plots display values for two sets of data. The data visualization is done as a collection of points not connected by lines. Each of them has its coordinates determined by the value of the variables 
(one variable determines the X position, the other the Y position).
'''
import matplotlib.pyplot as plt
import numpy as np
x = np.random.randn(1000)
y = np.random.randn(1000)
plt.scatter(x, y) --------------------------------------------------------------
plt.show()

##################################################
size = 50*np.random.randn(1000)
colors = np.random.rand(1000)
plt.scatter(x, y, s=size, c=colors);-
plt.show()

#######################
#Adding text
import numpy as np
import matplotlib.pyplot as plt
X = np.linspace(-4, 4, 1024)
Y = .25 * (X + 4.) * (X + 1.) * (X - 2.)
plt.text(-0.5, -0.25, 'Brackmard minimum')----------------------------------



plt.plot(X, Y, c = 'k')-------------------------------------------------------------
plt.show()





##########################################
	Seaborn: 
                              Seaborn is an amazing visualization library for statistical graphics plotting in Python. It provides beautiful default styles and color palettes to make statistical plots more attractive. It is built on top matplotlib library and is also closely integrated with the data structures from pandas.
 Seaborn aims to make visualization the central part of exploring and understanding data. It provides dataset-oriented APIs so that we can switch between different visual representations for the same variables for a better understanding of the dataset.

#How to use Seaborn for Data Visualization
#pip install seaborn

Seaborn is a library for making statistical graphics in Python. It builds on top of matplotlib and integrates closely with pandas data structures.
Seaborn helps you explore and understand your data. Its plotting functions operate on dataframes and arrays containing whole datasets and internally perform the necessary semantic mapping and statistical aggregation to produce informative plots. Its dataset-oriented, declarative API lets you focus on what the different elements of your plots mean, rather than on the details of how to draw them.
Seaborn is the only library we need to import for this simple example. By convention, it is imported with the shorthand sns.
Behind the scenes, seaborn uses matplotlib to draw its plots. For interactive work, it’s recommended to use a Jupyter/IPython interface in matplotlib mode, or else you’ll have to call matplotlib.pyplot.show() when you want to see the plot.
Different categories of plot in Seaborn 
Plots are basically used for visualizing the relationship between variables. Those variables can be either completely numerical or a category like a group, class, or division. Seaborn divides the plot into the below categories – 
 
•	Relational plots: This plot is used to understand the relation between two variables.
•	Categorical plots: This plot deals with categorical variables and how they can be visualized.
•	Distribution plots: This plot is used for examining univariate and bivariate distributions
•	Regression plots: The regression plots in Seaborn are primarily intended to add a visual guide that helps to emphasize patterns in a dataset during exploratory data analyses.
•	Matrix plots: A matrix plot is an array of scatterplots.
•	Multi-plot grids: It is a useful approach to draw multiple instances of the same plot on different subsets of the dataset.

import seaborn as sns
import pandas
import matplotlib.pyplot as plt
#Seaborn has 18 in-built datasets, 
#that can be found using the following command.
sns.get_dataset_names()
Out[77]: 
['anagrams',
 'anscombe',
 'attention',
 'brain_networks',
 'car_crashes',
 'diamonds',
 'dots',
 'dowjones',
 'exercise',
 'flights',
 'fmri',
 'geyser',
 'glue',
 'healthexp',
 'iris',
 'mpg',
 'penguins',
 'planets',
 'seaice',
 'taxis',
 'tips',
 'titanic']
df = sns.load_dataset('titanic')
df.head()
#Out[79]: 
   survived  pclass     sex   age  ...  deck  embark_town  alive  alone
0         0       3    male  22.0  ...   NaN  Southampton     no  False
1         1       1  female  38.0  ...     C    Cherbourg    yes  False
2         1       3  female  26.0  ...   NaN  Southampton    yes   True
3         1       1  female  35.0  ...     C  Southampton    yes  False
4         0       3    male  35.0  ...   NaN  Southampton     no   True

[5 rows x 15 columns]
#=====================================================     ^
#Count plot                                                                                                       l
'''                                                                                                                          l
A count plot is helpful when dealing with categorical values. It is used to plot the frequency of the different categories. The column sex contains categorical data in the     l   titanic data, i.e., male and female.                                                                l
'''                                                                                                                          l
sns.countplot(x='sex',data=df)----------------------------------------------------
#x - The name of the column.
#data - The dataframe.

sns.countplot(x='sex', hue = 'survived', data = df, 
palette = 'Set1') ------------------------------------------------------------------

sns.countplot(x='sex', hue = 'survived',
data = df, palette = 'Set2')------------------------------------------------------





sns.countplot(x='sex', hue = 'survived',
data = df, palette = 'Set3')--------------



#hue - The name of the categorical column to split the bars.
#palette - The color palette to be used. 

##############################################
	KDE Plot :
                      
                       A kernel density estimate (KDE) plot is a method for visualizing the distribution of observations in a dataset, analogous to a histogram. KDE represents the data using a continuous probability density curve in one or more dimensions.
The approach is explained further in the user guide.
Relative to a histogram, KDE can produce a plot that is less cluttered and more interpretable, especially when drawing multiple distributions. But it has the potential to introduce distortions if the underlying distribution is bounded or not smooth. Like a histogram, the quality of the representation also depends on the selection of good smoothing parameters.

#A Kernel Density Estimate (KDE) Plot is used 
#to plot the distribution of continuous data.
sns.kdeplot(x = 'age' , data = df , color = 'black')---------------------

# x - The name of the column.
#data - The dataframe.
#color - The color of the graph. You can find a list of colors here.
#Distribution plot

sns.displot(x = 'age',kde=True,bins = 6 , data =df)--------------------

#kde - It is set to False by default. However, if you wish to plot a KDE graph on top of the bars, you can set it to True.

 # bins - The number of bins/bars. 
 #The lower the number, wider the bars and wider the intervals.


sns.displot(x ='age',kde=True,bins = 5 ,
hue = df['survived'] , palette = 'Set1', data=df)--------------

#Scatter plot
#For this plot and the plots below,
# we will be working with the iris dataset. 
#The iris dataset contains data related 
#to flower’s petal size (petal length and petal width)
# and sepal size (sepal length and sepal width).
#These features are used to classify the type of iris
# (Setosa, Versicolour, and Virginica).

#First, we will need to load the iris dataset.
                            The Iris dataset is a widely recognized benchmark in data analysis and visualization using matplotlib and seaborn which are libraries of Python. This article presents a comprehensive guide on how to plot graphs for the Iris dataset using two powerful Python libraries: Seaborn and Matplotlib.

df = sns.load_dataset('iris')
df.head()
#Out[100]: 
   sepal_length  sepal_width  petal_length  petal_width species
0           5.1          3.5           1.4          0.2  setosa
1           4.9          3.0           1.4          0.2  setosa
2           4.7          3.2           1.3          0.2  setosa
3           4.6          3.1           1.5          0.2  setosa
4           5.0          3.6           1.4          0.2  setosa

#Scatter plots help understand co-relation between data,
sns.scatterplot(x='sepal_length', y ='petal_length' ,
data = df , hue = 'species')----------------------------------------------
#Out[101]: <Axes: xlabel='sepal_length', ylabel='petal_length'>

'''
In the plot above we can observe that an iris flower with a sepal length < 6cm and petal length < 2cm 
is most likely of type setosa. Although there is no distinct boundary present between the versicolor dots and virginica dots, an iris flower with petal length between 2cm and 5cm is most likely of type versicolor, 
while iris flowers with petal length > 5cm are most likely of type virginica.
'''

	Joint plot :

#A Joint Plot is also used to plot the correlation between data.

sns.jointplot(x='sepal_length' , y ='petal_length',
data = df , kind = 'reg')-----------------------------------------------------
#Out[102]: <seaborn.axisgrid.JointGrid at 0x2b728b0ae30>


sns.jointplot(x='sepal_length' , y ='petal_length',
data = df , kind = 'hist')-----------------------------------------------------------
#Out[103]: <seaborn.axisgrid.JointGrid at 0x2b72a3202b0>







sns.jointplot(x='sepal_length' , y ='petal_length',
data = df , kind = 'kde')-------------------------------------------------
Out[104]: <seaborn.axisgrid.JointGrid at 0x2b728a3d480>

'''
    kind - The kind of plot to be plotted. 
    It can be one of the following.

'scatter', 'hist', 'hex', 'kde', 'reg', 'resid'
'''

#Pair plots
sns.pairplot(df)
------------








###########################################
#A heat map can be used to visualize confusion, matrices, and correlation.
corr = df.corr()
sns.heatmap(corr)
#Out[107]: <Axes: >

########################################
#Visualizing the Pokemon dataset

This data set includes 721 Pokemon, including their number, name, first and second type, and basic stats: HP, Attack, Defense, Special Attack, Special Defense, and Speed. It has been of great use when teaching statistics to kids. With certain types you can also give a geeky introduction to machine learning.



import pandas as pd
pokemon_df = pd.read_csv('c:/10-python/pokemon.csv')
pokemon_df.head()

plt.figure(figsize=(15,8))
# Out[111]: <Figure size 1500x800 with 0 Axes>

sns.countplot(x = 'type1' , data = pokemon_df,
hue = 'is_legendary')
#Relation between Attack and Defense
sns.pairplot(x_vars=['attack' , 'defense','sp_attack','sp_defense'] ,
y_vars=['attack' , 'defense','sp_attack','sp_defense'] ,
data = pokemon_df)
#Relation between Height and Weight
sns.jointplot(x = 'weight_kg', y = 'height_m',
data = pokemon_df,hue = 'is_legendary')
#Based on the graph above, we can conclude that 
#height and weight of a Pokemon do not have 
#any correlation.


















